"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_family_lib_index-Cs-onntv_js"],{

/***/ "(app-pages-browser)/./node_modules/family/lib/index-Cs-onntv.js":
/*!***************************************************!*\
  !*** ./node_modules/family/lib/index-Cs-onntv.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   i: () => (/* binding */ index$1)\n/* harmony export */ });\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\nfunction _mergeNamespaces(n, m) {\n\tm.forEach(function (e) {\n\t\te && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {\n\t\t\tif (k !== 'default' && !(k in n)) {\n\t\t\t\tvar d = Object.getOwnPropertyDescriptor(e, k);\n\t\t\t\tObject.defineProperty(n, k, d.get ? d : {\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tget: function () { return e[k]; }\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t});\n\treturn Object.freeze(n);\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar postRobot$1 = {exports: {}};\n\nvar postRobot = {exports: {}};\n\n(function (module, exports) {\n\t!function(root, factory) {\n\t    module.exports = factory() ;\n\t}(\"undefined\" != typeof self ? self : commonjsGlobal, (function() {\n\t    return function(modules) {\n\t        var installedModules = {};\n\t        function __nested_webpack_require_1042__(moduleId) {\n\t            if (installedModules[moduleId]) return installedModules[moduleId].exports;\n\t            var module = installedModules[moduleId] = {\n\t                i: moduleId,\n\t                l: false,\n\t                exports: {}\n\t            };\n\t            modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_1042__);\n\t            module.l = true;\n\t            return module.exports;\n\t        }\n\t        __nested_webpack_require_1042__.m = modules;\n\t        __nested_webpack_require_1042__.c = installedModules;\n\t        __nested_webpack_require_1042__.d = function(exports, name, getter) {\n\t            __nested_webpack_require_1042__.o(exports, name) || Object.defineProperty(exports, name, {\n\t                enumerable: true,\n\t                get: getter\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.r = function(exports) {\n\t            \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {\n\t                value: \"Module\"\n\t            });\n\t            Object.defineProperty(exports, \"__esModule\", {\n\t                value: true\n\t            });\n\t        };\n\t        __nested_webpack_require_1042__.t = function(value, mode) {\n\t            1 & mode && (value = __nested_webpack_require_1042__(value));\n\t            if (8 & mode) return value;\n\t            if (4 & mode && \"object\" == typeof value && value && value.__esModule) return value;\n\t            var ns = Object.create(null);\n\t            __nested_webpack_require_1042__.r(ns);\n\t            Object.defineProperty(ns, \"default\", {\n\t                enumerable: true,\n\t                value: value\n\t            });\n\t            if (2 & mode && \"string\" != typeof value) for (var key in value) __nested_webpack_require_1042__.d(ns, key, function(key) {\n\t                return value[key];\n\t            }.bind(null, key));\n\t            return ns;\n\t        };\n\t        __nested_webpack_require_1042__.n = function(module) {\n\t            var getter = module && module.__esModule ? function() {\n\t                return module.default;\n\t            } : function() {\n\t                return module;\n\t            };\n\t            __nested_webpack_require_1042__.d(getter, \"a\", getter);\n\t            return getter;\n\t        };\n\t        __nested_webpack_require_1042__.o = function(object, property) {\n\t            return {}.hasOwnProperty.call(object, property);\n\t        };\n\t        __nested_webpack_require_1042__.p = \"\";\n\t        return __nested_webpack_require_1042__(__nested_webpack_require_1042__.s = 0);\n\t    }([ function(module, __nested_webpack_exports__, __nested_webpack_require_3517__) {\n\t        __nested_webpack_require_3517__.r(__nested_webpack_exports__);\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"Promise\", (function() {\n\t            return promise_ZalgoPromise;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"TYPES\", (function() {\n\t            return src_types_TYPES_0;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"ProxyWindow\", (function() {\n\t            return window_ProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"setup\", (function() {\n\t            return setup;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"destroy\", (function() {\n\t            return destroy;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"serializeMessage\", (function() {\n\t            return setup_serializeMessage;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"deserializeMessage\", (function() {\n\t            return setup_deserializeMessage;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"createProxyWindow\", (function() {\n\t            return createProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"toProxyWindow\", (function() {\n\t            return setup_toProxyWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"on\", (function() {\n\t            return on_on;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"once\", (function() {\n\t            return on_once;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"send\", (function() {\n\t            return send_send;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"markWindowKnown\", (function() {\n\t            return markWindowKnown;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"cleanUpWindow\", (function() {\n\t            return cleanUpWindow;\n\t        }));\n\t        __nested_webpack_require_3517__.d(__nested_webpack_exports__, \"bridge\", (function() {}));\n\t        function isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        var IE_WIN_ACCESS_ERROR = \"Call was rejected by callee.\\r\\n\";\n\t        function getActualProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return win.location.protocol;\n\t        }\n\t        function getProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            if (win.mockDomain) {\n\t                var protocol = win.mockDomain.split(\"//\")[0];\n\t                if (protocol) return protocol;\n\t            }\n\t            return getActualProtocol(win);\n\t        }\n\t        function isAboutProtocol(win) {\n\t            void 0 === win && (win = window);\n\t            return \"about:\" === getProtocol(win);\n\t        }\n\t        function getParent(win) {\n\t            void 0 === win && (win = window);\n\t            if (win) try {\n\t                if (win.parent && win.parent !== win) return win.parent;\n\t            } catch (err) {}\n\t        }\n\t        function getOpener(win) {\n\t            void 0 === win && (win = window);\n\t            if (win && !getParent(win)) try {\n\t                return win.opener;\n\t            } catch (err) {}\n\t        }\n\t        function canReadFromWindow(win) {\n\t            try {\n\t                return !0;\n\t            } catch (err) {}\n\t            return false;\n\t        }\n\t        function getActualDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var location = win.location;\n\t            if (!location) throw new Error(\"Can not read window location\");\n\t            var protocol = getActualProtocol(win);\n\t            if (!protocol) throw new Error(\"Can not read window protocol\");\n\t            if (\"file:\" === protocol) return \"file://\";\n\t            if (\"about:\" === protocol) {\n\t                var parent = getParent(win);\n\t                return parent && canReadFromWindow() ? getActualDomain(parent) : \"about://\";\n\t            }\n\t            var host = location.host;\n\t            if (!host) throw new Error(\"Can not read window host\");\n\t            return protocol + \"//\" + host;\n\t        }\n\t        function getDomain(win) {\n\t            void 0 === win && (win = window);\n\t            var domain = getActualDomain(win);\n\t            return domain && win.mockDomain && 0 === win.mockDomain.indexOf(\"mock:\") ? win.mockDomain : domain;\n\t        }\n\t        function isSameDomain(win) {\n\t            if (!function(win) {\n\t                try {\n\t                    if (win === window) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    var desc = Object.getOwnPropertyDescriptor(win, \"location\");\n\t                    if (desc && !1 === desc.enumerable) return !1;\n\t                } catch (err) {}\n\t                try {\n\t                    if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (function(win) {\n\t                        void 0 === win && (win = window);\n\t                        return \"mock:\" === getProtocol(win);\n\t                    }(win) && canReadFromWindow()) return !0;\n\t                } catch (err) {}\n\t                try {\n\t                    if (getActualDomain(win) === getActualDomain(window)) return !0;\n\t                } catch (err) {}\n\t                return false;\n\t            }(win)) return false;\n\t            try {\n\t                if (win === window) return !0;\n\t                if (isAboutProtocol(win) && canReadFromWindow()) return !0;\n\t                if (getDomain(window) === getDomain(win)) return !0;\n\t            } catch (err) {}\n\t            return false;\n\t        }\n\t        function assertSameDomain(win) {\n\t            if (!isSameDomain(win)) throw new Error(\"Expected window to be same domain\");\n\t            return win;\n\t        }\n\t        function isAncestorParent(parent, child) {\n\t            if (!parent || !child) return false;\n\t            var childParent = getParent(child);\n\t            return childParent ? childParent === parent : -1 !== function(win) {\n\t                var result = [];\n\t                try {\n\t                    for (;win.parent !== win; ) {\n\t                        result.push(win.parent);\n\t                        win = win.parent;\n\t                    }\n\t                } catch (err) {}\n\t                return result;\n\t            }(child).indexOf(parent);\n\t        }\n\t        function getFrames(win) {\n\t            var result = [];\n\t            var frames;\n\t            try {\n\t                frames = win.frames;\n\t            } catch (err) {\n\t                frames = win;\n\t            }\n\t            var len;\n\t            try {\n\t                len = frames.length;\n\t            } catch (err) {}\n\t            if (0 === len) return result;\n\t            if (len) {\n\t                for (var i = 0; i < len; i++) {\n\t                    var frame = void 0;\n\t                    try {\n\t                        frame = frames[i];\n\t                    } catch (err) {\n\t                        continue;\n\t                    }\n\t                    result.push(frame);\n\t                }\n\t                return result;\n\t            }\n\t            for (var _i = 0; _i < 100; _i++) {\n\t                var _frame = void 0;\n\t                try {\n\t                    _frame = frames[_i];\n\t                } catch (err) {\n\t                    return result;\n\t                }\n\t                if (!_frame) return result;\n\t                result.push(_frame);\n\t            }\n\t            return result;\n\t        }\n\t        var iframeWindows = [];\n\t        var iframeFrames = [];\n\t        function isWindowClosed(win, allowMock) {\n\t            void 0 === allowMock && (allowMock = true);\n\t            try {\n\t                if (win === window) return !1;\n\t            } catch (err) {\n\t                return true;\n\t            }\n\t            try {\n\t                if (!win) return !0;\n\t            } catch (err) {\n\t                return true;\n\t            }\n\t            try {\n\t                if (win.closed) return !0;\n\t            } catch (err) {\n\t                return !err || err.message !== IE_WIN_ACCESS_ERROR;\n\t            }\n\t            if (allowMock && isSameDomain(win)) try {\n\t                if (win.mockclosed) return !0;\n\t            } catch (err) {}\n\t            try {\n\t                if (!win.parent || !win.top) return !0;\n\t            } catch (err) {}\n\t            var iframeIndex = function(collection, item) {\n\t                for (var i = 0; i < collection.length; i++) try {\n\t                    if (collection[i] === item) return i;\n\t                } catch (err) {}\n\t                return -1;\n\t            }(iframeWindows, win);\n\t            if (-1 !== iframeIndex) {\n\t                var frame = iframeFrames[iframeIndex];\n\t                if (frame && function(frame) {\n\t                    if (!frame.contentWindow) return true;\n\t                    if (!frame.parentNode) return true;\n\t                    var doc = frame.ownerDocument;\n\t                    if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n\t                        var parent = frame;\n\t                        for (;parent.parentNode && parent.parentNode !== parent; ) parent = parent.parentNode;\n\t                        if (!parent.host || !doc.documentElement.contains(parent.host)) return true;\n\t                    }\n\t                    return false;\n\t                }(frame)) return true;\n\t            }\n\t            return false;\n\t        }\n\t        function getAncestor(win) {\n\t            void 0 === win && (win = window);\n\t            return getOpener(win = win || window) || getParent(win) || void 0;\n\t        }\n\t        function matchDomain(pattern, origin) {\n\t            if (\"string\" == typeof pattern) {\n\t                if (\"string\" == typeof origin) return \"*\" === pattern || origin === pattern;\n\t                if (isRegex(origin)) return false;\n\t                if (Array.isArray(origin)) return false;\n\t            }\n\t            return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some((function(subpattern) {\n\t                return matchDomain(subpattern, origin);\n\t            })));\n\t        }\n\t        function isWindow(obj) {\n\t            try {\n\t                if (obj === window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (\"[object Window]\" === {}.toString.call(obj)) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (window.Window && obj instanceof window.Window) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && obj.self === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && obj.parent === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && obj.top === obj) return !0;\n\t            } catch (err) {\n\t                if (err && err.message === IE_WIN_ACCESS_ERROR) return true;\n\t            }\n\t            try {\n\t                if (obj && \"__unlikely_value__\" === obj.__cross_domain_utils_window_check__) return !1;\n\t            } catch (err) {\n\t                return true;\n\t            }\n\t            try {\n\t                if (\"postMessage\" in obj && \"self\" in obj && \"location\" in obj) return !0;\n\t            } catch (err) {}\n\t            return false;\n\t        }\n\t        function getFrameForWindow(win) {\n\t            if (isSameDomain(win)) return assertSameDomain(win).frameElement;\n\t            for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll(\"iframe\"); _i21 < _document$querySelect2.length; _i21++) {\n\t                var frame = _document$querySelect2[_i21];\n\t                if (frame && frame.contentWindow && frame.contentWindow === win) return frame;\n\t            }\n\t        }\n\t        function closeWindow(win) {\n\t            if (function(win) {\n\t                void 0 === win && (win = window);\n\t                return Boolean(getParent(win));\n\t            }(win)) {\n\t                var frame = getFrameForWindow(win);\n\t                if (frame && frame.parentElement) {\n\t                    frame.parentElement.removeChild(frame);\n\t                    return;\n\t                }\n\t            }\n\t            try {\n\t                win.close();\n\t            } catch (err) {}\n\t        }\n\t        function utils_isPromise(item) {\n\t            try {\n\t                if (!item) return !1;\n\t                if (\"undefined\" != typeof Promise && item instanceof Promise) return !0;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.Window && item instanceof window.Window) return !1;\n\t                if (\"undefined\" != typeof window && \"function\" == typeof window.constructor && item instanceof window.constructor) return !1;\n\t                var _toString = {}.toString;\n\t                if (_toString) {\n\t                    var name = _toString.call(item);\n\t                    if (\"[object Window]\" === name || \"[object global]\" === name || \"[object DOMWindow]\" === name) return !1;\n\t                }\n\t                if (\"function\" == typeof item.then) return !0;\n\t            } catch (err) {\n\t                return false;\n\t            }\n\t            return false;\n\t        }\n\t        var dispatchedErrors = [];\n\t        var possiblyUnhandledPromiseHandlers = [];\n\t        var activeCount = 0;\n\t        var flushPromise;\n\t        function flushActive() {\n\t            if (!activeCount && flushPromise) {\n\t                var promise = flushPromise;\n\t                flushPromise = null;\n\t                promise.resolve();\n\t            }\n\t        }\n\t        function startActive() {\n\t            activeCount += 1;\n\t        }\n\t        function endActive() {\n\t            activeCount -= 1;\n\t            flushActive();\n\t        }\n\t        var promise_ZalgoPromise = function() {\n\t            function ZalgoPromise(handler) {\n\t                var _this = this;\n\t                this.resolved = void 0;\n\t                this.rejected = void 0;\n\t                this.errorHandled = void 0;\n\t                this.value = void 0;\n\t                this.error = void 0;\n\t                this.handlers = void 0;\n\t                this.dispatching = void 0;\n\t                this.stack = void 0;\n\t                this.resolved = false;\n\t                this.rejected = false;\n\t                this.errorHandled = false;\n\t                this.handlers = [];\n\t                if (handler) {\n\t                    var _result;\n\t                    var _error;\n\t                    var resolved = false;\n\t                    var rejected = false;\n\t                    var isAsync = false;\n\t                    startActive();\n\t                    try {\n\t                        handler((function(res) {\n\t                            if (isAsync) _this.resolve(res); else {\n\t                                resolved = !0;\n\t                                _result = res;\n\t                            }\n\t                        }), (function(err) {\n\t                            if (isAsync) _this.reject(err); else {\n\t                                rejected = !0;\n\t                                _error = err;\n\t                            }\n\t                        }));\n\t                    } catch (err) {\n\t                        endActive();\n\t                        this.reject(err);\n\t                        return;\n\t                    }\n\t                    endActive();\n\t                    isAsync = true;\n\t                    resolved ? this.resolve(_result) : rejected && this.reject(_error);\n\t                }\n\t            }\n\t            var _proto = ZalgoPromise.prototype;\n\t            _proto.resolve = function(result) {\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(result)) throw new Error(\"Can not resolve promise with another promise\");\n\t                this.resolved = true;\n\t                this.value = result;\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.reject = function(error) {\n\t                var _this2 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                if (utils_isPromise(error)) throw new Error(\"Can not reject promise with another promise\");\n\t                if (!error) {\n\t                    var _err = error && \"function\" == typeof error.toString ? error.toString() : {}.toString.call(error);\n\t                    error = new Error(\"Expected reject to be called with Error, got \" + _err);\n\t                }\n\t                this.rejected = true;\n\t                this.error = error;\n\t                this.errorHandled || setTimeout((function() {\n\t                    _this2.errorHandled || function(err, promise) {\n\t                        if (-1 === dispatchedErrors.indexOf(err)) {\n\t                            dispatchedErrors.push(err);\n\t                            setTimeout((function() {\n\t                                throw err;\n\t                            }), 1);\n\t                            for (var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++) possiblyUnhandledPromiseHandlers[j](err, promise);\n\t                        }\n\t                    }(error, _this2);\n\t                }), 1);\n\t                this.dispatch();\n\t                return this;\n\t            };\n\t            _proto.asyncReject = function(error) {\n\t                this.errorHandled = true;\n\t                this.reject(error);\n\t                return this;\n\t            };\n\t            _proto.dispatch = function() {\n\t                var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;\n\t                if (!this.dispatching && (resolved || rejected)) {\n\t                    this.dispatching = true;\n\t                    startActive();\n\t                    var chain = function(firstPromise, secondPromise) {\n\t                        return firstPromise.then((function(res) {\n\t                            secondPromise.resolve(res);\n\t                        }), (function(err) {\n\t                            secondPromise.reject(err);\n\t                        }));\n\t                    };\n\t                    for (var i = 0; i < handlers.length; i++) {\n\t                        var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;\n\t                        var _result2 = void 0;\n\t                        if (resolved) try {\n\t                            _result2 = onSuccess ? onSuccess(this.value) : this.value;\n\t                        } catch (err) {\n\t                            promise.reject(err);\n\t                            continue;\n\t                        } else if (rejected) {\n\t                            if (!onError) {\n\t                                promise.reject(this.error);\n\t                                continue;\n\t                            }\n\t                            try {\n\t                                _result2 = onError(this.error);\n\t                            } catch (err) {\n\t                                promise.reject(err);\n\t                                continue;\n\t                            }\n\t                        }\n\t                        if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {\n\t                            var promiseResult = _result2;\n\t                            promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);\n\t                            promiseResult.errorHandled = true;\n\t                        } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);\n\t                    }\n\t                    handlers.length = 0;\n\t                    this.dispatching = false;\n\t                    endActive();\n\t                }\n\t            };\n\t            _proto.then = function(onSuccess, onError) {\n\t                if (onSuccess && \"function\" != typeof onSuccess && !onSuccess.call) throw new Error(\"Promise.then expected a function for success handler\");\n\t                if (onError && \"function\" != typeof onError && !onError.call) throw new Error(\"Promise.then expected a function for error handler\");\n\t                var promise = new ZalgoPromise;\n\t                this.handlers.push({\n\t                    promise: promise,\n\t                    onSuccess: onSuccess,\n\t                    onError: onError\n\t                });\n\t                this.errorHandled = true;\n\t                this.dispatch();\n\t                return promise;\n\t            };\n\t            _proto.catch = function(onError) {\n\t                return this.then(void 0, onError);\n\t            };\n\t            _proto.finally = function(onFinally) {\n\t                if (onFinally && \"function\" != typeof onFinally && !onFinally.call) throw new Error(\"Promise.finally expected a function\");\n\t                return this.then((function(result) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        return result;\n\t                    }));\n\t                }), (function(err) {\n\t                    return ZalgoPromise.try(onFinally).then((function() {\n\t                        throw err;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.timeout = function(time, err) {\n\t                var _this3 = this;\n\t                if (this.resolved || this.rejected) return this;\n\t                var timeout = setTimeout((function() {\n\t                    _this3.resolved || _this3.rejected || _this3.reject(err || new Error(\"Promise timed out after \" + time + \"ms\"));\n\t                }), time);\n\t                return this.then((function(result) {\n\t                    clearTimeout(timeout);\n\t                    return result;\n\t                }));\n\t            };\n\t            _proto.toPromise = function() {\n\t                if (\"undefined\" == typeof Promise) throw new TypeError(\"Could not find Promise\");\n\t                return Promise.resolve(this);\n\t            };\n\t            _proto.lazy = function() {\n\t                this.errorHandled = true;\n\t                return this;\n\t            };\n\t            ZalgoPromise.resolve = function(value) {\n\t                return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise((function(resolve, reject) {\n\t                    return value.then(resolve, reject);\n\t                })) : (new ZalgoPromise).resolve(value);\n\t            };\n\t            ZalgoPromise.reject = function(error) {\n\t                return (new ZalgoPromise).reject(error);\n\t            };\n\t            ZalgoPromise.asyncReject = function(error) {\n\t                return (new ZalgoPromise).asyncReject(error);\n\t            };\n\t            ZalgoPromise.all = function(promises) {\n\t                var promise = new ZalgoPromise;\n\t                var count = promises.length;\n\t                var results = [].slice();\n\t                if (!count) {\n\t                    promise.resolve(results);\n\t                    return promise;\n\t                }\n\t                var chain = function(i, firstPromise, secondPromise) {\n\t                    return firstPromise.then((function(res) {\n\t                        results[i] = res;\n\t                        0 == (count -= 1) && promise.resolve(results);\n\t                    }), (function(err) {\n\t                        secondPromise.reject(err);\n\t                    }));\n\t                };\n\t                for (var i = 0; i < promises.length; i++) {\n\t                    var prom = promises[i];\n\t                    if (prom instanceof ZalgoPromise) {\n\t                        if (prom.resolved) {\n\t                            results[i] = prom.value;\n\t                            count -= 1;\n\t                            continue;\n\t                        }\n\t                    } else if (!utils_isPromise(prom)) {\n\t                        results[i] = prom;\n\t                        count -= 1;\n\t                        continue;\n\t                    }\n\t                    chain(i, ZalgoPromise.resolve(prom), promise);\n\t                }\n\t                0 === count && promise.resolve(results);\n\t                return promise;\n\t            };\n\t            ZalgoPromise.hash = function(promises) {\n\t                var result = {};\n\t                var awaitPromises = [];\n\t                var _loop = function(key) {\n\t                    if (promises.hasOwnProperty(key)) {\n\t                        var value = promises[key];\n\t                        utils_isPromise(value) ? awaitPromises.push(value.then((function(res) {\n\t                            result[key] = res;\n\t                        }))) : result[key] = value;\n\t                    }\n\t                };\n\t                for (var key in promises) _loop(key);\n\t                return ZalgoPromise.all(awaitPromises).then((function() {\n\t                    return result;\n\t                }));\n\t            };\n\t            ZalgoPromise.map = function(items, method) {\n\t                return ZalgoPromise.all(items.map(method));\n\t            };\n\t            ZalgoPromise.onPossiblyUnhandledException = function(handler) {\n\t                return function(handler) {\n\t                    possiblyUnhandledPromiseHandlers.push(handler);\n\t                    return {\n\t                        cancel: function() {\n\t                            possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);\n\t                        }\n\t                    };\n\t                }(handler);\n\t            };\n\t            ZalgoPromise.try = function(method, context, args) {\n\t                if (method && \"function\" != typeof method && !method.call) throw new Error(\"Promise.try expected a function\");\n\t                var result;\n\t                startActive();\n\t                try {\n\t                    result = method.apply(context, args || []);\n\t                } catch (err) {\n\t                    endActive();\n\t                    return ZalgoPromise.reject(err);\n\t                }\n\t                endActive();\n\t                return ZalgoPromise.resolve(result);\n\t            };\n\t            ZalgoPromise.delay = function(_delay) {\n\t                return new ZalgoPromise((function(resolve) {\n\t                    setTimeout(resolve, _delay);\n\t                }));\n\t            };\n\t            ZalgoPromise.isPromise = function(value) {\n\t                return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);\n\t            };\n\t            ZalgoPromise.flush = function() {\n\t                return function(Zalgo) {\n\t                    var promise = flushPromise = flushPromise || new Zalgo;\n\t                    flushActive();\n\t                    return promise;\n\t                }(ZalgoPromise);\n\t            };\n\t            return ZalgoPromise;\n\t        }();\n\t        function util_safeIndexOf(collection, item) {\n\t            for (var i = 0; i < collection.length; i++) try {\n\t                if (collection[i] === item) return i;\n\t            } catch (err) {}\n\t            return -1;\n\t        }\n\t        var weakmap_CrossDomainSafeWeakMap = function() {\n\t            function CrossDomainSafeWeakMap() {\n\t                this.name = void 0;\n\t                this.weakmap = void 0;\n\t                this.keys = void 0;\n\t                this.values = void 0;\n\t                this.name = \"__weakmap_\" + (1e9 * Math.random() >>> 0) + \"__\";\n\t                if (function() {\n\t                    if (\"undefined\" == typeof WeakMap) return false;\n\t                    if (void 0 === Object.freeze) return false;\n\t                    try {\n\t                        var testWeakMap = new WeakMap;\n\t                        var testKey = {};\n\t                        Object.freeze(testKey);\n\t                        testWeakMap.set(testKey, \"__testvalue__\");\n\t                        return \"__testvalue__\" === testWeakMap.get(testKey);\n\t                    } catch (err) {\n\t                        return false;\n\t                    }\n\t                }()) try {\n\t                    this.weakmap = new WeakMap;\n\t                } catch (err) {}\n\t                this.keys = [];\n\t                this.values = [];\n\t            }\n\t            var _proto = CrossDomainSafeWeakMap.prototype;\n\t            _proto._cleanupClosedWindows = function() {\n\t                var weakmap = this.weakmap;\n\t                var keys = this.keys;\n\t                for (var i = 0; i < keys.length; i++) {\n\t                    var value = keys[i];\n\t                    if (isWindow(value) && isWindowClosed(value)) {\n\t                        if (weakmap) try {\n\t                            weakmap.delete(value);\n\t                        } catch (err) {}\n\t                        keys.splice(i, 1);\n\t                        this.values.splice(i, 1);\n\t                        i -= 1;\n\t                    }\n\t                }\n\t            };\n\t            _proto.isSafeToReadWrite = function(key) {\n\t                return !isWindow(key);\n\t            };\n\t            _proto.set = function(key, value) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.set(key, value);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var name = this.name;\n\t                    var entry = key[name];\n\t                    entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {\n\t                        value: [ key, value ],\n\t                        writable: !0\n\t                    });\n\t                    return;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var values = this.values;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 === index) {\n\t                    keys.push(key);\n\t                    values.push(value);\n\t                } else values[index] = value;\n\t            };\n\t            _proto.get = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return weakmap.get(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return entry && entry[0] === key ? entry[1] : void 0;\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var index = util_safeIndexOf(this.keys, key);\n\t                if (-1 !== index) return this.values[index];\n\t            };\n\t            _proto.delete = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    weakmap.delete(key);\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    entry && entry[0] === key && (entry[0] = entry[1] = void 0);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                var keys = this.keys;\n\t                var index = util_safeIndexOf(keys, key);\n\t                if (-1 !== index) {\n\t                    keys.splice(index, 1);\n\t                    this.values.splice(index, 1);\n\t                }\n\t            };\n\t            _proto.has = function(key) {\n\t                if (!key) throw new Error(\"WeakMap expected key\");\n\t                var weakmap = this.weakmap;\n\t                if (weakmap) try {\n\t                    if (weakmap.has(key)) return !0;\n\t                } catch (err) {\n\t                    delete this.weakmap;\n\t                }\n\t                if (this.isSafeToReadWrite(key)) try {\n\t                    var entry = key[this.name];\n\t                    return !(!entry || entry[0] !== key);\n\t                } catch (err) {}\n\t                this._cleanupClosedWindows();\n\t                return -1 !== util_safeIndexOf(this.keys, key);\n\t            };\n\t            _proto.getOrSet = function(key, getter) {\n\t                if (this.has(key)) return this.get(key);\n\t                var value = getter();\n\t                this.set(key, value);\n\t                return value;\n\t            };\n\t            return CrossDomainSafeWeakMap;\n\t        }();\n\t        function getFunctionName(fn) {\n\t            return fn.name || fn.__name__ || fn.displayName || \"anonymous\";\n\t        }\n\t        function setFunctionName(fn, name) {\n\t            try {\n\t                delete fn.name;\n\t                fn.name = name;\n\t            } catch (err) {}\n\t            fn.__name__ = fn.displayName = name;\n\t            return fn;\n\t        }\n\t        function uniqueID() {\n\t            var chars = \"0123456789abcdef\";\n\t            return \"uid_\" + \"xxxxxxxxxx\".replace(/./g, (function() {\n\t                return chars.charAt(Math.floor(Math.random() * chars.length));\n\t            })) + \"_\" + function(str) {\n\t                if (\"function\" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (function(m, p1) {\n\t                    return String.fromCharCode(parseInt(p1, 16));\n\t                }))).replace(/[=]/g, \"\");\n\t                if (\"undefined\" != typeof Buffer) return Buffer.from(str, \"utf8\").toString(\"base64\").replace(/[=]/g, \"\");\n\t                throw new Error(\"Can not find window.btoa or Buffer\");\n\t            }((new Date).toISOString().slice(11, 19).replace(\"T\", \".\")).replace(/[^a-zA-Z0-9]/g, \"\").toLowerCase();\n\t        }\n\t        var objectIDs;\n\t        function serializeArgs(args) {\n\t            try {\n\t                return JSON.stringify([].slice.call(args), (function(subkey, val) {\n\t                    return \"function\" == typeof val ? \"memoize[\" + function(obj) {\n\t                        objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;\n\t                        if (null == obj || \"object\" != typeof obj && \"function\" != typeof obj) throw new Error(\"Invalid object\");\n\t                        var uid = objectIDs.get(obj);\n\t                        if (!uid) {\n\t                            uid = typeof obj + \":\" + uniqueID();\n\t                            objectIDs.set(obj, uid);\n\t                        }\n\t                        return uid;\n\t                    }(val) + \"]\" : \"undefined\" != typeof window && val instanceof window.Element || null !== val && \"object\" == typeof val && 1 === val.nodeType && \"object\" == typeof val.style && \"object\" == typeof val.ownerDocument ? {} : val;\n\t                }));\n\t            } catch (err) {\n\t                throw new Error(\"Arguments not serializable -- can not be used to memoize\");\n\t            }\n\t        }\n\t        function getEmptyObject() {\n\t            return {};\n\t        }\n\t        var memoizeGlobalIndex = 0;\n\t        var memoizeGlobalIndexValidFrom = 0;\n\t        function memoize(method, options) {\n\t            void 0 === options && (options = {});\n\t            var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;\n\t            var simpleCache;\n\t            var thisCache;\n\t            var memoizeIndex = memoizeGlobalIndex;\n\t            memoizeGlobalIndex += 1;\n\t            var memoizedFunction = function() {\n\t                for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];\n\t                if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n\t                    simpleCache = null;\n\t                    thisCache = null;\n\t                    memoizeIndex = memoizeGlobalIndex;\n\t                    memoizeGlobalIndex += 1;\n\t                }\n\t                var cache;\n\t                cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};\n\t                var cacheKey;\n\t                try {\n\t                    cacheKey = serializeArgs(args);\n\t                } catch (_unused) {\n\t                    return method.apply(this, arguments);\n\t                }\n\t                var cacheResult = cache[cacheKey];\n\t                if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n\t                    delete cache[cacheKey];\n\t                    cacheResult = null;\n\t                }\n\t                if (cacheResult) return cacheResult.value;\n\t                var time = Date.now();\n\t                var value = method.apply(this, arguments);\n\t                cache[cacheKey] = {\n\t                    time: time,\n\t                    value: value\n\t                };\n\t                return value;\n\t            };\n\t            memoizedFunction.reset = function() {\n\t                simpleCache = null;\n\t                thisCache = null;\n\t            };\n\t            return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + \"::memoized\");\n\t        }\n\t        memoize.clear = function() {\n\t            memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n\t        };\n\t        function memoizePromise(method) {\n\t            var cache = {};\n\t            function memoizedPromiseFunction() {\n\t                var _arguments = arguments, _this = this;\n\t                for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];\n\t                var key = serializeArgs(args);\n\t                if (cache.hasOwnProperty(key)) return cache[key];\n\t                cache[key] = promise_ZalgoPromise.try((function() {\n\t                    return method.apply(_this, _arguments);\n\t                })).finally((function() {\n\t                    delete cache[key];\n\t                }));\n\t                return cache[key];\n\t            }\n\t            memoizedPromiseFunction.reset = function() {\n\t                cache = {};\n\t            };\n\t            return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + \"::promiseMemoized\");\n\t        }\n\t        function src_util_noop() {}\n\t        function stringifyError(err, level) {\n\t            void 0 === level && (level = 1);\n\t            if (level >= 3) return \"stringifyError stack overflow\";\n\t            try {\n\t                if (!err) return \"<unknown error: \" + {}.toString.call(err) + \">\";\n\t                if (\"string\" == typeof err) return err;\n\t                if (err instanceof Error) {\n\t                    var stack = err && err.stack;\n\t                    var message = err && err.message;\n\t                    if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + \"\\n\" + stack;\n\t                    if (stack) return stack;\n\t                    if (message) return message;\n\t                }\n\t                return err && err.toString && \"function\" == typeof err.toString ? err.toString() : {}.toString.call(err);\n\t            } catch (newErr) {\n\t                return \"Error while stringifying error: \" + stringifyError(newErr, level + 1);\n\t            }\n\t        }\n\t        function stringify(item) {\n\t            return \"string\" == typeof item ? item : item.toString && \"function\" == typeof item.toString ? item.toString() : {}.toString.call(item);\n\t        }\n\t        memoize((function(obj) {\n\t            if (Object.values) return Object.values(obj);\n\t            var result = [];\n\t            for (var key in obj) obj.hasOwnProperty(key) && result.push(obj[key]);\n\t            return result;\n\t        }));\n\t        function util_isRegex(item) {\n\t            return \"[object RegExp]\" === {}.toString.call(item);\n\t        }\n\t        function util_getOrSet(obj, key, getter) {\n\t            if (obj.hasOwnProperty(key)) return obj[key];\n\t            var val = getter();\n\t            obj[key] = val;\n\t            return val;\n\t        }\n\t        function getBody() {\n\t            var body = document.body;\n\t            if (!body) throw new Error(\"Body element not found\");\n\t            return body;\n\t        }\n\t        function isDocumentReady() {\n\t            return Boolean(document.body) && \"complete\" === document.readyState;\n\t        }\n\t        function isDocumentInteractive() {\n\t            return Boolean(document.body) && \"interactive\" === document.readyState;\n\t        }\n\t        memoize((function() {\n\t            return new promise_ZalgoPromise((function(resolve) {\n\t                if (isDocumentReady() || isDocumentInteractive()) return resolve();\n\t                var interval = setInterval((function() {\n\t                    if (isDocumentReady() || isDocumentInteractive()) {\n\t                        clearInterval(interval);\n\t                        return resolve();\n\t                    }\n\t                }), 10);\n\t            }));\n\t        }));\n\t        var currentScript = \"undefined\" != typeof document ? document.currentScript : null;\n\t        var getCurrentScript = memoize((function() {\n\t            if (currentScript) return currentScript;\n\t            if (currentScript = function() {\n\t                try {\n\t                    var stack = function() {\n\t                        try {\n\t                            throw new Error(\"_\");\n\t                        } catch (err) {\n\t                            return err.stack || \"\";\n\t                        }\n\t                    }();\n\t                    var stackDetails = /.*at [^(]*\\((.*):(.+):(.+)\\)$/gi.exec(stack);\n\t                    var scriptLocation = stackDetails && stackDetails[1];\n\t                    if (!scriptLocation) return;\n\t                    for (var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName(\"script\")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++) {\n\t                        var script = _Array$prototype$slic2[_i22];\n\t                        if (script.src && script.src === scriptLocation) return script;\n\t                    }\n\t                } catch (err) {}\n\t            }()) return currentScript;\n\t            throw new Error(\"Can not determine current script\");\n\t        }));\n\t        var currentUID = uniqueID();\n\t        memoize((function() {\n\t            var script;\n\t            try {\n\t                script = getCurrentScript();\n\t            } catch (err) {\n\t                return currentUID;\n\t            }\n\t            var uid = script.getAttribute(\"data-uid\");\n\t            if (uid && \"string\" == typeof uid) return uid;\n\t            if ((uid = script.getAttribute(\"data-uid-auto\")) && \"string\" == typeof uid) return uid;\n\t            if (script.src) {\n\t                var hashedString = function(str) {\n\t                    var hash = \"\";\n\t                    for (var i = 0; i < str.length; i++) {\n\t                        var total = str[i].charCodeAt(0) * i;\n\t                        str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));\n\t                        hash += String.fromCharCode(97 + Math.abs(total) % 26);\n\t                    }\n\t                    return hash;\n\t                }(JSON.stringify({\n\t                    src: script.src,\n\t                    dataset: script.dataset\n\t                }));\n\t                uid = \"uid_\" + hashedString.slice(hashedString.length - 30);\n\t            } else uid = uniqueID();\n\t            script.setAttribute(\"data-uid-auto\", uid);\n\t            return uid;\n\t        }));\n\t        function global_getGlobal(win) {\n\t            void 0 === win && (win = window);\n\t            var globalKey = \"__post_robot_10_0_46__\";\n\t            return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};\n\t        }\n\t        var getObj = function() {\n\t            return {};\n\t        };\n\t        function globalStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return util_getOrSet(global_getGlobal(), key, (function() {\n\t                var store = defStore();\n\t                return {\n\t                    has: function(storeKey) {\n\t                        return store.hasOwnProperty(storeKey);\n\t                    },\n\t                    get: function(storeKey, defVal) {\n\t                        return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;\n\t                    },\n\t                    set: function(storeKey, val) {\n\t                        store[storeKey] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(storeKey) {\n\t                        delete store[storeKey];\n\t                    },\n\t                    getOrSet: function(storeKey, getter) {\n\t                        return util_getOrSet(store, storeKey, getter);\n\t                    },\n\t                    reset: function() {\n\t                        store = defStore();\n\t                    },\n\t                    keys: function() {\n\t                        return Object.keys(store);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        var WildCard = function() {};\n\t        function getWildcard() {\n\t            var global = global_getGlobal();\n\t            global.WINDOW_WILDCARD = global.WINDOW_WILDCARD || new WildCard;\n\t            return global.WINDOW_WILDCARD;\n\t        }\n\t        function windowStore(key, defStore) {\n\t            void 0 === key && (key = \"store\");\n\t            void 0 === defStore && (defStore = getObj);\n\t            return globalStore(\"windowStore\").getOrSet(key, (function() {\n\t                var winStore = new weakmap_CrossDomainSafeWeakMap;\n\t                var getStore = function(win) {\n\t                    return winStore.getOrSet(win, defStore);\n\t                };\n\t                return {\n\t                    has: function(win) {\n\t                        return getStore(win).hasOwnProperty(key);\n\t                    },\n\t                    get: function(win, defVal) {\n\t                        var store = getStore(win);\n\t                        return store.hasOwnProperty(key) ? store[key] : defVal;\n\t                    },\n\t                    set: function(win, val) {\n\t                        getStore(win)[key] = val;\n\t                        return val;\n\t                    },\n\t                    del: function(win) {\n\t                        delete getStore(win)[key];\n\t                    },\n\t                    getOrSet: function(win, getter) {\n\t                        return util_getOrSet(getStore(win), key, getter);\n\t                    }\n\t                };\n\t            }));\n\t        }\n\t        function getInstanceID() {\n\t            return globalStore(\"instance\").getOrSet(\"instanceID\", uniqueID);\n\t        }\n\t        function resolveHelloPromise(win, _ref) {\n\t            var domain = _ref.domain;\n\t            var helloPromises = windowStore(\"helloPromises\");\n\t            var existingPromise = helloPromises.get(win);\n\t            existingPromise && existingPromise.resolve({\n\t                domain: domain\n\t            });\n\t            var newPromise = promise_ZalgoPromise.resolve({\n\t                domain: domain\n\t            });\n\t            helloPromises.set(win, newPromise);\n\t            return newPromise;\n\t        }\n\t        function sayHello(win, _ref4) {\n\t            return (0, _ref4.send)(win, \"postrobot_hello\", {\n\t                instanceID: getInstanceID()\n\t            }, {\n\t                domain: \"*\",\n\t                timeout: -1\n\t            }).then((function(_ref5) {\n\t                var origin = _ref5.origin, instanceID = _ref5.data.instanceID;\n\t                resolveHelloPromise(win, {\n\t                    domain: origin\n\t                });\n\t                return {\n\t                    win: win,\n\t                    domain: origin,\n\t                    instanceID: instanceID\n\t                };\n\t            }));\n\t        }\n\t        function getWindowInstanceID(win, _ref6) {\n\t            var send = _ref6.send;\n\t            return windowStore(\"windowInstanceIDPromises\").getOrSet(win, (function() {\n\t                return sayHello(win, {\n\t                    send: send\n\t                }).then((function(_ref7) {\n\t                    return _ref7.instanceID;\n\t                }));\n\t            }));\n\t        }\n\t        function markWindowKnown(win) {\n\t            windowStore(\"knownWindows\").set(win, true);\n\t        }\n\t        function isSerializedType(item) {\n\t            return \"object\" == typeof item && null !== item && \"string\" == typeof item.__type__;\n\t        }\n\t        function determineType(val) {\n\t            return void 0 === val ? \"undefined\" : null === val ? \"null\" : Array.isArray(val) ? \"array\" : \"function\" == typeof val ? \"function\" : \"object\" == typeof val ? val instanceof Error ? \"error\" : \"function\" == typeof val.then ? \"promise\" : \"[object RegExp]\" === {}.toString.call(val) ? \"regex\" : \"[object Date]\" === {}.toString.call(val) ? \"date\" : \"object\" : \"string\" == typeof val ? \"string\" : \"number\" == typeof val ? \"number\" : \"boolean\" == typeof val ? \"boolean\" : void 0;\n\t        }\n\t        function serializeType(type, val) {\n\t            return {\n\t                __type__: type,\n\t                __val__: val\n\t            };\n\t        }\n\t        var _SERIALIZER;\n\t        var SERIALIZER = ((_SERIALIZER = {}).function = function() {}, _SERIALIZER.error = function(_ref) {\n\t            return serializeType(\"error\", {\n\t                message: _ref.message,\n\t                stack: _ref.stack,\n\t                code: _ref.code,\n\t                data: _ref.data\n\t            });\n\t        }, _SERIALIZER.promise = function() {}, _SERIALIZER.regex = function(val) {\n\t            return serializeType(\"regex\", val.source);\n\t        }, _SERIALIZER.date = function(val) {\n\t            return serializeType(\"date\", val.toJSON());\n\t        }, _SERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _SERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _SERIALIZER[void 0] = function(val) {\n\t            return serializeType(\"undefined\", val);\n\t        }, _SERIALIZER);\n\t        var defaultSerializers = {};\n\t        var _DESERIALIZER;\n\t        var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {\n\t            throw new Error(\"Function serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.error = function(_ref2) {\n\t            var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;\n\t            var error = new Error(_ref2.message);\n\t            error.code = code;\n\t            data && (error.data = data);\n\t            error.stack = stack + \"\\n\\n\" + error.stack;\n\t            return error;\n\t        }, _DESERIALIZER.promise = function() {\n\t            throw new Error(\"Promise serialization is not implemented; nothing to deserialize\");\n\t        }, _DESERIALIZER.regex = function(val) {\n\t            return new RegExp(val);\n\t        }, _DESERIALIZER.date = function(val) {\n\t            return new Date(val);\n\t        }, _DESERIALIZER.array = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.object = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.string = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.number = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.boolean = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER.null = function(val) {\n\t            return val;\n\t        }, _DESERIALIZER[void 0] = function() {}, _DESERIALIZER);\n\t        var defaultDeserializers = {};\n\t        new promise_ZalgoPromise((function(resolve) {\n\t            if (window.document && window.document.body) return resolve(window.document.body);\n\t            var interval = setInterval((function() {\n\t                if (window.document && window.document.body) {\n\t                    clearInterval(interval);\n\t                    return resolve(window.document.body);\n\t                }\n\t            }), 10);\n\t        }));\n\t        function cleanupProxyWindows() {\n\t            var idToProxyWindow = globalStore(\"idToProxyWindow\");\n\t            for (var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++) {\n\t                var id = _idToProxyWindow$keys2[_i2];\n\t                idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);\n\t            }\n\t        }\n\t        function getSerializedWindow(winPromise, _ref) {\n\t            var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;\n\t            var windowNamePromise = winPromise.then((function(win) {\n\t                if (isSameDomain(win)) return assertSameDomain(win).name;\n\t            }));\n\t            var windowTypePromise = winPromise.then((function(window) {\n\t                if (isWindowClosed(window)) throw new Error(\"Window is closed, can not determine type\");\n\t                return getOpener(window) ? \"popup\" : \"iframe\";\n\t            }));\n\t            windowNamePromise.catch(src_util_noop);\n\t            windowTypePromise.catch(src_util_noop);\n\t            var getName = function() {\n\t                return winPromise.then((function(win) {\n\t                    if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;\n\t                }));\n\t            };\n\t            return {\n\t                id: id,\n\t                getType: function() {\n\t                    return windowTypePromise;\n\t                },\n\t                getInstanceID: memoizePromise((function() {\n\t                    return winPromise.then((function(win) {\n\t                        return getWindowInstanceID(win, {\n\t                            send: send\n\t                        });\n\t                    }));\n\t                })),\n\t                close: function() {\n\t                    return winPromise.then(closeWindow);\n\t                },\n\t                getName: getName,\n\t                focus: function() {\n\t                    return winPromise.then((function(win) {\n\t                        win.focus();\n\t                    }));\n\t                },\n\t                isClosed: function() {\n\t                    return winPromise.then((function(win) {\n\t                        return isWindowClosed(win);\n\t                    }));\n\t                },\n\t                setLocation: function(href, opts) {\n\t                    void 0 === opts && (opts = {});\n\t                    return winPromise.then((function(win) {\n\t                        var domain = window.location.protocol + \"//\" + window.location.host;\n\t                        var _opts$method = opts.method, method = void 0 === _opts$method ? \"get\" : _opts$method, body = opts.body;\n\t                        if (0 === href.indexOf(\"/\")) href = \"\" + domain + href; else if (!href.match(/^https?:\\/\\//) && 0 !== href.indexOf(domain)) throw new Error(\"Expected url to be http or https url, or absolute path, got \" + JSON.stringify(href));\n\t                        if (\"post\" === method) return getName().then((function(name) {\n\t                            if (!name) throw new Error(\"Can not post to window without target name\");\n\t                            !function(_ref3) {\n\t                                var url = _ref3.url, target = _ref3.target, body = _ref3.body, _ref3$method = _ref3.method, method = void 0 === _ref3$method ? \"post\" : _ref3$method;\n\t                                var form = document.createElement(\"form\");\n\t                                form.setAttribute(\"target\", target);\n\t                                form.setAttribute(\"method\", method);\n\t                                form.setAttribute(\"action\", url);\n\t                                form.style.display = \"none\";\n\t                                if (body) for (var _i24 = 0, _Object$keys4 = Object.keys(body); _i24 < _Object$keys4.length; _i24++) {\n\t                                    var _body$key;\n\t                                    var key = _Object$keys4[_i24];\n\t                                    var input = document.createElement(\"input\");\n\t                                    input.setAttribute(\"name\", key);\n\t                                    input.setAttribute(\"value\", null == (_body$key = body[key]) ? void 0 : _body$key.toString());\n\t                                    form.appendChild(input);\n\t                                }\n\t                                getBody().appendChild(form);\n\t                                form.submit();\n\t                                getBody().removeChild(form);\n\t                            }({\n\t                                url: href,\n\t                                target: name,\n\t                                method: method,\n\t                                body: body\n\t                            });\n\t                        }));\n\t                        if (\"get\" !== method) throw new Error(\"Unsupported method: \" + method);\n\t                        if (isSameDomain(win)) try {\n\t                            if (win.location && \"function\" == typeof win.location.replace) {\n\t                                win.location.replace(href);\n\t                                return;\n\t                            }\n\t                        } catch (err) {}\n\t                        win.location = href;\n\t                    }));\n\t                },\n\t                setName: function(name) {\n\t                    return winPromise.then((function(win) {\n\t                        var sameDomain = isSameDomain(win);\n\t                        var frame = getFrameForWindow(win);\n\t                        if (!sameDomain) throw new Error(\"Can not set name for cross-domain window: \" + name);\n\t                        assertSameDomain(win).name = name;\n\t                        frame && frame.setAttribute(\"name\", name);\n\t                        windowNamePromise = promise_ZalgoPromise.resolve(name);\n\t                    }));\n\t                }\n\t            };\n\t        }\n\t        var window_ProxyWindow = function() {\n\t            function ProxyWindow(_ref2) {\n\t                var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;\n\t                this.id = void 0;\n\t                this.isProxyWindow = true;\n\t                this.serializedWindow = void 0;\n\t                this.actualWindow = void 0;\n\t                this.actualWindowPromise = void 0;\n\t                this.send = void 0;\n\t                this.name = void 0;\n\t                this.actualWindowPromise = new promise_ZalgoPromise;\n\t                this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send\n\t                });\n\t                globalStore(\"idToProxyWindow\").set(this.getID(), this);\n\t                win && this.setWindow(win, {\n\t                    send: send\n\t                });\n\t            }\n\t            var _proto = ProxyWindow.prototype;\n\t            _proto.getID = function() {\n\t                return this.serializedWindow.id;\n\t            };\n\t            _proto.getType = function() {\n\t                return this.serializedWindow.getType();\n\t            };\n\t            _proto.isPopup = function() {\n\t                return this.getType().then((function(type) {\n\t                    return \"popup\" === type;\n\t                }));\n\t            };\n\t            _proto.setLocation = function(href, opts) {\n\t                var _this = this;\n\t                return this.serializedWindow.setLocation(href, opts).then((function() {\n\t                    return _this;\n\t                }));\n\t            };\n\t            _proto.getName = function() {\n\t                return this.serializedWindow.getName();\n\t            };\n\t            _proto.setName = function(name) {\n\t                var _this2 = this;\n\t                return this.serializedWindow.setName(name).then((function() {\n\t                    return _this2;\n\t                }));\n\t            };\n\t            _proto.close = function() {\n\t                var _this3 = this;\n\t                return this.serializedWindow.close().then((function() {\n\t                    return _this3;\n\t                }));\n\t            };\n\t            _proto.focus = function() {\n\t                var _this4 = this;\n\t                var isPopupPromise = this.isPopup();\n\t                var getNamePromise = this.getName();\n\t                var reopenPromise = promise_ZalgoPromise.hash({\n\t                    isPopup: isPopupPromise,\n\t                    name: getNamePromise\n\t                }).then((function(_ref3) {\n\t                    var name = _ref3.name;\n\t                    _ref3.isPopup && name && window.open(\"\", name, \"noopener\");\n\t                }));\n\t                var focusPromise = this.serializedWindow.focus();\n\t                return promise_ZalgoPromise.all([ reopenPromise, focusPromise ]).then((function() {\n\t                    return _this4;\n\t                }));\n\t            };\n\t            _proto.isClosed = function() {\n\t                return this.serializedWindow.isClosed();\n\t            };\n\t            _proto.getWindow = function() {\n\t                return this.actualWindow;\n\t            };\n\t            _proto.setWindow = function(win, _ref4) {\n\t                var send = _ref4.send;\n\t                this.actualWindow = win;\n\t                this.actualWindowPromise.resolve(this.actualWindow);\n\t                this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {\n\t                    send: send,\n\t                    id: this.getID()\n\t                });\n\t                windowStore(\"winToProxyWindow\").set(win, this);\n\t            };\n\t            _proto.awaitWindow = function() {\n\t                return this.actualWindowPromise;\n\t            };\n\t            _proto.matchWindow = function(win, _ref5) {\n\t                var _this5 = this;\n\t                var send = _ref5.send;\n\t                return promise_ZalgoPromise.try((function() {\n\t                    return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({\n\t                        proxyInstanceID: _this5.getInstanceID(),\n\t                        knownWindowInstanceID: getWindowInstanceID(win, {\n\t                            send: send\n\t                        })\n\t                    }).then((function(_ref6) {\n\t                        var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;\n\t                        match && _this5.setWindow(win, {\n\t                            send: send\n\t                        });\n\t                        return match;\n\t                    }));\n\t                }));\n\t            };\n\t            _proto.unwrap = function() {\n\t                return this.actualWindow || this;\n\t            };\n\t            _proto.getInstanceID = function() {\n\t                return this.serializedWindow.getInstanceID();\n\t            };\n\t            _proto.shouldClean = function() {\n\t                return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));\n\t            };\n\t            _proto.serialize = function() {\n\t                return this.serializedWindow;\n\t            };\n\t            ProxyWindow.unwrap = function(win) {\n\t                return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;\n\t            };\n\t            ProxyWindow.serialize = function(win, _ref7) {\n\t                var send = _ref7.send;\n\t                cleanupProxyWindows();\n\t                return ProxyWindow.toProxyWindow(win, {\n\t                    send: send\n\t                }).serialize();\n\t            };\n\t            ProxyWindow.deserialize = function(serializedWindow, _ref8) {\n\t                var send = _ref8.send;\n\t                cleanupProxyWindows();\n\t                return globalStore(\"idToProxyWindow\").get(serializedWindow.id) || new ProxyWindow({\n\t                    serializedWindow: serializedWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            ProxyWindow.isProxyWindow = function(obj) {\n\t                return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);\n\t            };\n\t            ProxyWindow.toProxyWindow = function(win, _ref9) {\n\t                var send = _ref9.send;\n\t                cleanupProxyWindows();\n\t                if (ProxyWindow.isProxyWindow(win)) return win;\n\t                var actualWindow = win;\n\t                return windowStore(\"winToProxyWindow\").get(actualWindow) || new ProxyWindow({\n\t                    win: actualWindow,\n\t                    send: send\n\t                });\n\t            };\n\t            return ProxyWindow;\n\t        }();\n\t        function addMethod(id, val, name, source, domain) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {\n\t                val: val,\n\t                name: name,\n\t                domain: domain,\n\t                source: source\n\t            }); else {\n\t                proxyWindowMethods.del(id);\n\t                methodStore.getOrSet(source, (function() {\n\t                    return {};\n\t                }))[id] = {\n\t                    domain: domain,\n\t                    name: name,\n\t                    val: val,\n\t                    source: source\n\t                };\n\t            }\n\t        }\n\t        function lookupMethod(source, id) {\n\t            var methodStore = windowStore(\"methodStore\");\n\t            var proxyWindowMethods = globalStore(\"proxyWindowMethods\");\n\t            return methodStore.getOrSet(source, (function() {\n\t                return {};\n\t            }))[id] || proxyWindowMethods.get(id);\n\t        }\n\t        function function_serializeFunction(destination, domain, val, key, _ref3) {\n\t            on = (_ref = {\n\t                on: _ref3.on,\n\t                send: _ref3.send\n\t            }).on, send = _ref.send, globalStore(\"builtinListeners\").getOrSet(\"functionCalls\", (function() {\n\t                return on(\"postrobot_method\", {\n\t                    domain: \"*\"\n\t                }, (function(_ref2) {\n\t                    var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;\n\t                    var id = data.id, name = data.name;\n\t                    var meth = lookupMethod(source, id);\n\t                    if (!meth) throw new Error(\"Could not find method '\" + name + \"' with id: \" + data.id + \" in \" + getDomain(window));\n\t                    var methodSource = meth.source, domain = meth.domain, val = meth.val;\n\t                    return promise_ZalgoPromise.try((function() {\n\t                        if (!matchDomain(domain, origin)) throw new Error(\"Method '\" + data.name + \"' domain \" + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + \" does not match origin \" + origin + \" in \" + getDomain(window));\n\t                        if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {\n\t                            send: send\n\t                        }).then((function(match) {\n\t                            if (!match) throw new Error(\"Method call '\" + data.name + \"' failed - proxy window does not match source in \" + getDomain(window));\n\t                        }));\n\t                    })).then((function() {\n\t                        return val.apply({\n\t                            source: source,\n\t                            origin: origin\n\t                        }, data.args);\n\t                    }), (function(err) {\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            if (val.onError) return val.onError(err);\n\t                        })).then((function() {\n\t                            err.stack && (err.stack = \"Remote call to \" + name + \"(\" + function(args) {\n\t                                void 0 === args && (args = []);\n\t                                return (item = args, [].slice.call(item)).map((function(arg) {\n\t                                    return \"string\" == typeof arg ? \"'\" + arg + \"'\" : void 0 === arg ? \"undefined\" : null === arg ? \"null\" : \"boolean\" == typeof arg ? arg.toString() : Array.isArray(arg) ? \"[ ... ]\" : \"object\" == typeof arg ? \"{ ... }\" : \"function\" == typeof arg ? \"() => { ... }\" : \"<\" + typeof arg + \">\";\n\t                                })).join(\", \");\n\t                                var item;\n\t                            }(data.args) + \") failed\\n\\n\" + err.stack);\n\t                            throw err;\n\t                        }));\n\t                    })).then((function(result) {\n\t                        return {\n\t                            result: result,\n\t                            id: id,\n\t                            name: name\n\t                        };\n\t                    }));\n\t                }));\n\t            }));\n\t            var _ref, on, send;\n\t            var id = val.__id__ || uniqueID();\n\t            destination = window_ProxyWindow.unwrap(destination);\n\t            var name = val.__name__ || val.name || key;\n\t            \"string\" == typeof name && \"function\" == typeof name.indexOf && 0 === name.indexOf(\"anonymous::\") && (name = name.replace(\"anonymous::\", key + \"::\"));\n\t            if (window_ProxyWindow.isProxyWindow(destination)) {\n\t                addMethod(id, val, name, destination, domain);\n\t                destination.awaitWindow().then((function(win) {\n\t                    addMethod(id, val, name, win, domain);\n\t                }));\n\t            } else addMethod(id, val, name, destination, domain);\n\t            return serializeType(\"cross_domain_function\", {\n\t                id: id,\n\t                name: name\n\t            });\n\t        }\n\t        function serializeMessage(destination, domain, obj, _ref) {\n\t            var _serialize;\n\t            var on = _ref.on, send = _ref.send;\n\t            return function(obj, serializers) {\n\t                void 0 === serializers && (serializers = defaultSerializers);\n\t                var result = JSON.stringify(obj, (function(key) {\n\t                    var val = this[key];\n\t                    if (isSerializedType(this)) return val;\n\t                    var type = determineType(val);\n\t                    if (!type) return val;\n\t                    var serializer = serializers[type] || SERIALIZER[type];\n\t                    return serializer ? serializer(val, key) : val;\n\t                }));\n\t                return void 0 === result ? \"undefined\" : result;\n\t            }(obj, ((_serialize = {}).promise = function(val, key) {\n\t                return function(destination, domain, val, key, _ref) {\n\t                    return serializeType(\"cross_domain_zalgo_promise\", {\n\t                        then: function_serializeFunction(destination, domain, (function(resolve, reject) {\n\t                            return val.then(resolve, reject);\n\t                        }), key, {\n\t                            on: _ref.on,\n\t                            send: _ref.send\n\t                        })\n\t                    });\n\t                }(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.function = function(val, key) {\n\t                return function_serializeFunction(destination, domain, val, key, {\n\t                    on: on,\n\t                    send: send\n\t                });\n\t            }, _serialize.object = function(val) {\n\t                return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType(\"cross_domain_window\", window_ProxyWindow.serialize(val, {\n\t                    send: send\n\t                })) : val;\n\t            }, _serialize));\n\t        }\n\t        function deserializeMessage(source, origin, message, _ref2) {\n\t            var _deserialize;\n\t            var send = _ref2.send;\n\t            return function(str, deserializers) {\n\t                void 0 === deserializers && (deserializers = defaultDeserializers);\n\t                if (\"undefined\" !== str) return JSON.parse(str, (function(key, val) {\n\t                    if (isSerializedType(this)) return val;\n\t                    var type;\n\t                    var value;\n\t                    if (isSerializedType(val)) {\n\t                        type = val.__type__;\n\t                        value = val.__val__;\n\t                    } else {\n\t                        type = determineType(val);\n\t                        value = val;\n\t                    }\n\t                    if (!type) return value;\n\t                    var deserializer = deserializers[type] || DESERIALIZER[type];\n\t                    return deserializer ? deserializer(value, key) : value;\n\t                }));\n\t            }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {\n\t                return function(source, origin, _ref2) {\n\t                    return new promise_ZalgoPromise(_ref2.then);\n\t                }(0, 0, serializedPromise);\n\t            }, _deserialize.cross_domain_function = function(serializedFunction) {\n\t                return function(source, origin, _ref4, _ref5) {\n\t                    var id = _ref4.id, name = _ref4.name;\n\t                    var send = _ref5.send;\n\t                    var getDeserializedFunction = function(opts) {\n\t                        void 0 === opts && (opts = {});\n\t                        function crossDomainFunctionWrapper() {\n\t                            var _arguments = arguments;\n\t                            return window_ProxyWindow.toProxyWindow(source, {\n\t                                send: send\n\t                            }).awaitWindow().then((function(win) {\n\t                                var meth = lookupMethod(win, id);\n\t                                if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({\n\t                                    source: window,\n\t                                    origin: getDomain()\n\t                                }, _arguments);\n\t                                var _args = [].slice.call(_arguments);\n\t                                return opts.fireAndForget ? send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: true\n\t                                }) : send(win, \"postrobot_method\", {\n\t                                    id: id,\n\t                                    name: name,\n\t                                    args: _args\n\t                                }, {\n\t                                    domain: origin,\n\t                                    fireAndForget: false\n\t                                }).then((function(res) {\n\t                                    return res.data.result;\n\t                                }));\n\t                            })).catch((function(err) {\n\t                                throw err;\n\t                            }));\n\t                        }\n\t                        crossDomainFunctionWrapper.__name__ = name;\n\t                        crossDomainFunctionWrapper.__origin__ = origin;\n\t                        crossDomainFunctionWrapper.__source__ = source;\n\t                        crossDomainFunctionWrapper.__id__ = id;\n\t                        crossDomainFunctionWrapper.origin = origin;\n\t                        return crossDomainFunctionWrapper;\n\t                    };\n\t                    var crossDomainFunctionWrapper = getDeserializedFunction();\n\t                    crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({\n\t                        fireAndForget: true\n\t                    });\n\t                    return crossDomainFunctionWrapper;\n\t                }(source, origin, serializedFunction, {\n\t                    send: send\n\t                });\n\t            }, _deserialize.cross_domain_window = function(serializedWindow) {\n\t                return window_ProxyWindow.deserialize(serializedWindow, {\n\t                    send: send\n\t                });\n\t            }, _deserialize));\n\t        }\n\t        var SEND_MESSAGE_STRATEGIES = {};\n\t        SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {\n\t            0 === domain.indexOf(\"file:\") && (domain = \"*\");\n\t            win.postMessage(serializedMessage, domain);\n\t        };\n\t        function send_sendMessage(win, domain, message, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            return promise_ZalgoPromise.try((function() {\n\t                var domainBuffer = windowStore().getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                domainBuffer.buffer = domainBuffer.buffer || [];\n\t                domainBuffer.buffer.push(message);\n\t                domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then((function() {\n\t                    if (isWindowClosed(win)) throw new Error(\"Window is closed\");\n\t                    var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_46__ = domainBuffer.buffer || [], \n\t                    _ref), {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                    var _ref;\n\t                    delete domainBuffer.buffer;\n\t                    var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);\n\t                    var errors = [];\n\t                    for (var _i2 = 0; _i2 < strategies.length; _i2++) {\n\t                        var strategyName = strategies[_i2];\n\t                        try {\n\t                            SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);\n\t                        } catch (err) {\n\t                            errors.push(err);\n\t                        }\n\t                    }\n\t                    if (errors.length === strategies.length) throw new Error(\"All post-robot messaging strategies failed:\\n\\n\" + errors.map((function(err, i) {\n\t                        return i + \". \" + stringifyError(err);\n\t                    })).join(\"\\n\\n\"));\n\t                }));\n\t                return domainBuffer.flush.then((function() {\n\t                    delete domainBuffer.flush;\n\t                }));\n\t            })).then(src_util_noop);\n\t        }\n\t        function getResponseListener(hash) {\n\t            return globalStore(\"responseListeners\").get(hash);\n\t        }\n\t        function deleteResponseListener(hash) {\n\t            globalStore(\"responseListeners\").del(hash);\n\t        }\n\t        function isResponseListenerErrored(hash) {\n\t            return globalStore(\"erroredResponseListeners\").has(hash);\n\t        }\n\t        function getRequestListener(_ref) {\n\t            var name = _ref.name, win = _ref.win, domain = _ref.domain;\n\t            var requestListeners = windowStore(\"requestListeners\");\n\t            \"*\" === win && (win = null);\n\t            \"*\" === domain && (domain = null);\n\t            if (!name) throw new Error(\"Name required to get request listener\");\n\t            for (var _i4 = 0, _ref3 = [ win, getWildcard() ]; _i4 < _ref3.length; _i4++) {\n\t                var winQualifier = _ref3[_i4];\n\t                if (winQualifier) {\n\t                    var nameListeners = requestListeners.get(winQualifier);\n\t                    if (nameListeners) {\n\t                        var domainListeners = nameListeners[name];\n\t                        if (domainListeners) {\n\t                            if (domain && \"string\" == typeof domain) {\n\t                                if (domainListeners[domain]) return domainListeners[domain];\n\t                                if (domainListeners.__domain_regex__) for (var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++) {\n\t                                    var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;\n\t                                    if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;\n\t                                }\n\t                            }\n\t                            if (domainListeners[\"*\"]) return domainListeners[\"*\"];\n\t                        }\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function handleRequest(source, origin, message, _ref) {\n\t            var on = _ref.on, send = _ref.send;\n\t            var options = getRequestListener({\n\t                name: message.name,\n\t                win: source,\n\t                domain: origin\n\t            });\n\t            var logName = \"postrobot_method\" === message.name && message.data && \"string\" == typeof message.data.name ? message.data.name + \"()\" : message.name;\n\t            function sendResponse(ack, data, error) {\n\t                return promise_ZalgoPromise.flush().then((function() {\n\t                    if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                        return send_sendMessage(source, origin, {\n\t                            id: uniqueID(),\n\t                            origin: getDomain(window),\n\t                            type: \"postrobot_message_response\",\n\t                            hash: message.hash,\n\t                            name: message.name,\n\t                            ack: ack,\n\t                            data: data,\n\t                            error: error\n\t                        }, {\n\t                            on: on,\n\t                            send: send\n\t                        });\n\t                    } catch (err) {\n\t                        throw new Error(\"Send response message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }\n\t                }));\n\t            }\n\t            return promise_ZalgoPromise.all([ promise_ZalgoPromise.flush().then((function() {\n\t                if (!message.fireAndForget && !isWindowClosed(source)) try {\n\t                    return send_sendMessage(source, origin, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_ack\",\n\t                        hash: message.hash,\n\t                        name: message.name\n\t                    }, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    throw new Error(\"Send ack message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                }\n\t            })), promise_ZalgoPromise.try((function() {\n\t                if (!options) throw new Error(\"No handler found for post message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                return options.handler({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            })).then((function(data) {\n\t                return sendResponse(\"success\", data);\n\t            }), (function(error) {\n\t                return sendResponse(\"error\", null, error);\n\t            })) ]).then(src_util_noop).catch((function(err) {\n\t                if (options && options.handleError) return options.handleError(err);\n\t                throw err;\n\t            }));\n\t        }\n\t        function handleAck(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message ack for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                try {\n\t                    if (!matchDomain(options.domain, origin)) throw new Error(\"Ack origin \" + origin + \" does not match domain \" + options.domain.toString());\n\t                    if (source !== options.win) throw new Error(\"Ack source does not match registered window\");\n\t                } catch (err) {\n\t                    options.promise.reject(err);\n\t                }\n\t                options.ack = true;\n\t            }\n\t        }\n\t        function handleResponse(source, origin, message) {\n\t            if (!isResponseListenerErrored(message.hash)) {\n\t                var options = getResponseListener(message.hash);\n\t                if (!options) throw new Error(\"No handler found for post message response for message: \" + message.name + \" from \" + origin + \" in \" + window.location.protocol + \"//\" + window.location.host + window.location.pathname);\n\t                if (!matchDomain(options.domain, origin)) throw new Error(\"Response origin \" + origin + \" does not match domain \" + (pattern = options.domain, \n\t                Array.isArray(pattern) ? \"(\" + pattern.join(\" | \") + \")\" : isRegex(pattern) ? \"RegExp(\" + pattern.toString() + \")\" : pattern.toString()));\n\t                var pattern;\n\t                if (source !== options.win) throw new Error(\"Response source does not match registered window\");\n\t                deleteResponseListener(message.hash);\n\t                \"error\" === message.ack ? options.promise.reject(message.error) : \"success\" === message.ack && options.promise.resolve({\n\t                    source: source,\n\t                    origin: origin,\n\t                    data: message.data\n\t                });\n\t            }\n\t        }\n\t        function receive_receiveMessage(event, _ref2) {\n\t            var on = _ref2.on, send = _ref2.send;\n\t            var receivedMessages = globalStore(\"receivedMessages\");\n\t            try {\n\t                if (!window || window.closed || !event.source) return;\n\t            } catch (err) {\n\t                return;\n\t            }\n\t            var source = event.source, origin = event.origin;\n\t            var messages = function(message, source, origin, _ref) {\n\t                var on = _ref.on, send = _ref.send;\n\t                var parsedMessage;\n\t                try {\n\t                    parsedMessage = deserializeMessage(source, origin, message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                } catch (err) {\n\t                    return;\n\t                }\n\t                if (parsedMessage && \"object\" == typeof parsedMessage && null !== parsedMessage) {\n\t                    var parseMessages = parsedMessage.__post_robot_10_0_46__;\n\t                    if (Array.isArray(parseMessages)) return parseMessages;\n\t                }\n\t            }(event.data, source, origin, {\n\t                on: on,\n\t                send: send\n\t            });\n\t            if (messages) {\n\t                markWindowKnown(source);\n\t                for (var _i2 = 0; _i2 < messages.length; _i2++) {\n\t                    var message = messages[_i2];\n\t                    if (receivedMessages.has(message.id)) return;\n\t                    receivedMessages.set(message.id, true);\n\t                    if (isWindowClosed(source) && !message.fireAndForget) return;\n\t                    0 === message.origin.indexOf(\"file:\") && (origin = \"file://\");\n\t                    try {\n\t                        \"postrobot_message_request\" === message.type ? handleRequest(source, origin, message, {\n\t                            on: on,\n\t                            send: send\n\t                        }) : \"postrobot_message_response\" === message.type ? handleResponse(source, origin, message) : \"postrobot_message_ack\" === message.type && handleAck(source, origin, message);\n\t                    } catch (err) {\n\t                        setTimeout((function() {\n\t                            throw err;\n\t                        }), 0);\n\t                    }\n\t                }\n\t            }\n\t        }\n\t        function on_on(name, options, handler) {\n\t            if (!name) throw new Error(\"Expected name\");\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            if (!handler) throw new Error(\"Expected handler\");\n\t            var requestListener = function addRequestListener(_ref4, listener) {\n\t                var name = _ref4.name, winCandidate = _ref4.win, domain = _ref4.domain;\n\t                var requestListeners = windowStore(\"requestListeners\");\n\t                if (!name || \"string\" != typeof name) throw new Error(\"Name required to add request listener\");\n\t                if (winCandidate && \"*\" !== winCandidate && window_ProxyWindow.isProxyWindow(winCandidate)) {\n\t                    var requestListenerPromise = winCandidate.awaitWindow().then((function(actualWin) {\n\t                        return addRequestListener({\n\t                            name: name,\n\t                            win: actualWin,\n\t                            domain: domain\n\t                        }, listener);\n\t                    }));\n\t                    return {\n\t                        cancel: function() {\n\t                            requestListenerPromise.then((function(requestListener) {\n\t                                return requestListener.cancel();\n\t                            }), src_util_noop);\n\t                        }\n\t                    };\n\t                }\n\t                var win = winCandidate;\n\t                if (Array.isArray(win)) {\n\t                    var listenersCollection = [];\n\t                    for (var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++) listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        domain: domain,\n\t                        win: _win2[_i8]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i10 = 0; _i10 < listenersCollection.length; _i10++) listenersCollection[_i10].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                if (Array.isArray(domain)) {\n\t                    var _listenersCollection = [];\n\t                    for (var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++) _listenersCollection.push(addRequestListener({\n\t                        name: name,\n\t                        win: win,\n\t                        domain: _domain2[_i12]\n\t                    }, listener));\n\t                    return {\n\t                        cancel: function() {\n\t                            for (var _i14 = 0; _i14 < _listenersCollection.length; _i14++) _listenersCollection[_i14].cancel();\n\t                        }\n\t                    };\n\t                }\n\t                var existingListener = getRequestListener({\n\t                    name: name,\n\t                    win: win,\n\t                    domain: domain\n\t                });\n\t                win && \"*\" !== win || (win = getWildcard());\n\t                var strDomain = (domain = domain || \"*\").toString();\n\t                if (existingListener) throw win && domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString() + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : win ? new Error(\"Request listener already exists for \" + name + \" for \" + (win === getWildcard() ? \"wildcard\" : \"specified\") + \" window\") : domain ? new Error(\"Request listener already exists for \" + name + \" on domain \" + domain.toString()) : new Error(\"Request listener already exists for \" + name);\n\t                var winNameListeners = requestListeners.getOrSet(win, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainListeners = util_getOrSet(winNameListeners, name, (function() {\n\t                    return {};\n\t                }));\n\t                var winNameDomainRegexListeners;\n\t                var winNameDomainRegexListener;\n\t                util_isRegex(domain) ? (winNameDomainRegexListeners = util_getOrSet(winNameDomainListeners, \"__domain_regex__\", (function() {\n\t                    return [];\n\t                }))).push(winNameDomainRegexListener = {\n\t                    regex: domain,\n\t                    listener: listener\n\t                }) : winNameDomainListeners[strDomain] = listener;\n\t                return {\n\t                    cancel: function() {\n\t                        delete winNameDomainListeners[strDomain];\n\t                        if (winNameDomainRegexListener) {\n\t                            winNameDomainRegexListeners.splice(winNameDomainRegexListeners.indexOf(winNameDomainRegexListener, 1));\n\t                            winNameDomainRegexListeners.length || delete winNameDomainListeners.__domain_regex__;\n\t                        }\n\t                        Object.keys(winNameDomainListeners).length || delete winNameListeners[name];\n\t                        win && !Object.keys(winNameListeners).length && requestListeners.del(win);\n\t                    }\n\t                };\n\t            }({\n\t                name: name,\n\t                win: options.window,\n\t                domain: options.domain || \"*\"\n\t            }, {\n\t                handler: handler || options.handler,\n\t                handleError: options.errorHandler || function(err) {\n\t                    throw err;\n\t                }\n\t            });\n\t            return {\n\t                cancel: function() {\n\t                    requestListener.cancel();\n\t                }\n\t            };\n\t        }\n\t        function on_once(name, options, handler) {\n\t            if (\"function\" == typeof (options = options || {})) {\n\t                handler = options;\n\t                options = {};\n\t            }\n\t            var promise = new promise_ZalgoPromise;\n\t            var listener;\n\t            options.errorHandler = function(err) {\n\t                listener.cancel();\n\t                promise.reject(err);\n\t            };\n\t            listener = on_on(name, options, (function(event) {\n\t                listener.cancel();\n\t                promise.resolve(event);\n\t                if (handler) return handler(event);\n\t            }));\n\t            promise.cancel = listener.cancel;\n\t            return promise;\n\t        }\n\t        var send_send = function send(winOrProxyWin, name, data, options) {\n\t            var domainMatcher = (options = options || {}).domain || \"*\";\n\t            var responseTimeout = options.timeout || -1;\n\t            var childTimeout = options.timeout || 5e3;\n\t            var fireAndForget = options.fireAndForget || false;\n\t            return window_ProxyWindow.toProxyWindow(winOrProxyWin, {\n\t                send: send\n\t            }).awaitWindow().then((function(win) {\n\t                return promise_ZalgoPromise.try((function() {\n\t                    !function(name, win, domain) {\n\t                        if (!name) throw new Error(\"Expected name\");\n\t                        if (\"string\" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError(\"Can not send \" + name + \". Expected domain \" + JSON.stringify(domain) + \" to be a string, array, or regex\");\n\t                        if (isWindowClosed(win)) throw new Error(\"Can not send \" + name + \". Target window is closed\");\n\t                    }(name, win, domainMatcher);\n\t                    if (function(parent, child) {\n\t                        var actualParent = getAncestor(child);\n\t                        if (actualParent) return actualParent === parent;\n\t                        if (child === parent) return false;\n\t                        if (function(win) {\n\t                            void 0 === win && (win = window);\n\t                            try {\n\t                                if (win.top) return win.top;\n\t                            } catch (err) {}\n\t                            if (getParent(win) === win) return win;\n\t                            try {\n\t                                if (isAncestorParent(window, win) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            try {\n\t                                if (isAncestorParent(win, window) && window.top) return window.top;\n\t                            } catch (err) {}\n\t                            for (var _i7 = 0, _getAllChildFrames4 = function getAllChildFrames(win) {\n\t                                var result = [];\n\t                                for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {\n\t                                    var frame = _getFrames2[_i3];\n\t                                    result.push(frame);\n\t                                    for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) result.push(_getAllChildFrames2[_i5]);\n\t                                }\n\t                                return result;\n\t                            }(win); _i7 < _getAllChildFrames4.length; _i7++) {\n\t                                var frame = _getAllChildFrames4[_i7];\n\t                                try {\n\t                                    if (frame.top) return frame.top;\n\t                                } catch (err) {}\n\t                                if (getParent(frame) === frame) return frame;\n\t                            }\n\t                        }(child) === child) return false;\n\t                        for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) if (_getFrames8[_i15] === child) return true;\n\t                        return false;\n\t                    }(window, win)) return function(win, timeout, name) {\n\t                        void 0 === timeout && (timeout = 5e3);\n\t                        void 0 === name && (name = \"Window\");\n\t                        var promise = function(win) {\n\t                            return windowStore(\"helloPromises\").getOrSet(win, (function() {\n\t                                return new promise_ZalgoPromise;\n\t                            }));\n\t                        }(win);\n\t                        -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + \" did not load after \" + timeout + \"ms\")));\n\t                        return promise;\n\t                    }(win, childTimeout);\n\t                })).then((function(_temp) {\n\t                    return function(win, targetDomain, actualDomain, _ref) {\n\t                        var send = _ref.send;\n\t                        return promise_ZalgoPromise.try((function() {\n\t                            return \"string\" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try((function() {\n\t                                return actualDomain || sayHello(win, {\n\t                                    send: send\n\t                                }).then((function(_ref2) {\n\t                                    return _ref2.domain;\n\t                                }));\n\t                            })).then((function(normalizedDomain) {\n\t                                if (!matchDomain(targetDomain, targetDomain)) throw new Error(\"Domain \" + stringify(targetDomain) + \" does not match \" + stringify(targetDomain));\n\t                                return normalizedDomain;\n\t                            }));\n\t                        }));\n\t                    }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {\n\t                        send: send\n\t                    });\n\t                })).then((function(targetDomain) {\n\t                    var domain = targetDomain;\n\t                    var logName = \"postrobot_method\" === name && data && \"string\" == typeof data.name ? data.name + \"()\" : name;\n\t                    var promise = new promise_ZalgoPromise;\n\t                    var hash = name + \"_\" + uniqueID();\n\t                    if (!fireAndForget) {\n\t                        var responseListener = {\n\t                            name: name,\n\t                            win: win,\n\t                            domain: domain,\n\t                            promise: promise\n\t                        };\n\t                        !function(hash, listener) {\n\t                            globalStore(\"responseListeners\").set(hash, listener);\n\t                        }(hash, responseListener);\n\t                        var reqPromises = windowStore(\"requestPromises\").getOrSet(win, (function() {\n\t                            return [];\n\t                        }));\n\t                        reqPromises.push(promise);\n\t                        promise.catch((function() {\n\t                            !function(hash) {\n\t                                globalStore(\"erroredResponseListeners\").set(hash, true);\n\t                            }(hash);\n\t                            deleteResponseListener(hash);\n\t                        }));\n\t                        var totalAckTimeout = function(win) {\n\t                            return windowStore(\"knownWindows\").get(win, false);\n\t                        }(win) ? 1e4 : 2e3;\n\t                        var totalResTimeout = responseTimeout;\n\t                        var ackTimeout = totalAckTimeout;\n\t                        var resTimeout = totalResTimeout;\n\t                        var interval = function(method, time) {\n\t                            var timeout;\n\t                            !function loop() {\n\t                                timeout = setTimeout((function() {\n\t                                    !function() {\n\t                                        if (isWindowClosed(win)) return promise.reject(new Error(\"Window closed for \" + name + \" before \" + (responseListener.ack ? \"response\" : \"ack\")));\n\t                                        if (responseListener.cancelled) return promise.reject(new Error(\"Response listener was cancelled for \" + name));\n\t                                        ackTimeout = Math.max(ackTimeout - 500, 0);\n\t                                        -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));\n\t                                        responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout && promise.reject(new Error(\"No response for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalResTimeout + \"ms\")) : promise.reject(new Error(\"No ack for postMessage \" + logName + \" in \" + getDomain() + \" in \" + totalAckTimeout + \"ms\"));\n\t                                    }();\n\t                                    loop();\n\t                                }), 500);\n\t                            }();\n\t                            return {\n\t                                cancel: function() {\n\t                                    clearTimeout(timeout);\n\t                                }\n\t                            };\n\t                        }();\n\t                        promise.finally((function() {\n\t                            interval.cancel();\n\t                            reqPromises.splice(reqPromises.indexOf(promise, 1));\n\t                        })).catch(src_util_noop);\n\t                    }\n\t                    return send_sendMessage(win, domain, {\n\t                        id: uniqueID(),\n\t                        origin: getDomain(window),\n\t                        type: \"postrobot_message_request\",\n\t                        hash: hash,\n\t                        name: name,\n\t                        data: data,\n\t                        fireAndForget: fireAndForget\n\t                    }, {\n\t                        on: on_on,\n\t                        send: send\n\t                    }).then((function() {\n\t                        return fireAndForget ? promise.resolve() : promise;\n\t                    }), (function(err) {\n\t                        throw new Error(\"Send request message failed for \" + logName + \" in \" + getDomain() + \"\\n\\n\" + stringifyError(err));\n\t                    }));\n\t                }));\n\t            }));\n\t        };\n\t        function setup_serializeMessage(destination, domain, obj) {\n\t            return serializeMessage(destination, domain, obj, {\n\t                on: on_on,\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup_deserializeMessage(source, origin, message) {\n\t            return deserializeMessage(source, origin, message, {\n\t                send: send_send\n\t            });\n\t        }\n\t        function createProxyWindow(win) {\n\t            return new window_ProxyWindow({\n\t                send: send_send,\n\t                win: win\n\t            });\n\t        }\n\t        function setup_toProxyWindow(win) {\n\t            return window_ProxyWindow.toProxyWindow(win, {\n\t                send: send_send\n\t            });\n\t        }\n\t        function setup() {\n\t            if (!global_getGlobal().initialized) {\n\t                global_getGlobal().initialized = true;\n\t                on = (_ref3 = {\n\t                    on: on_on,\n\t                    send: send_send\n\t                }).on, send = _ref3.send, (global = global_getGlobal()).receiveMessage = global.receiveMessage || function(message) {\n\t                    return receive_receiveMessage(message, {\n\t                        on: on,\n\t                        send: send\n\t                    });\n\t                };\n\t                !function(_ref5) {\n\t                    var on = _ref5.on, send = _ref5.send;\n\t                    globalStore().getOrSet(\"postMessageListener\", (function() {\n\t                        return function(obj, event, handler) {\n\t                            obj.addEventListener(\"message\", handler);\n\t                            return {\n\t                                cancel: function() {\n\t                                    obj.removeEventListener(\"message\", handler);\n\t                                }\n\t                            };\n\t                        }(window, 0, (function(event) {\n\t                            !function(event, _ref4) {\n\t                                var on = _ref4.on, send = _ref4.send;\n\t                                promise_ZalgoPromise.try((function() {\n\t                                    var source = event.source || event.sourceElement;\n\t                                    var origin = event.origin || event.originalEvent && event.originalEvent.origin;\n\t                                    var data = event.data;\n\t                                    \"null\" === origin && (origin = \"file://\");\n\t                                    if (source) {\n\t                                        if (!origin) throw new Error(\"Post message did not have origin domain\");\n\t                                        receive_receiveMessage({\n\t                                            source: source,\n\t                                            origin: origin,\n\t                                            data: data\n\t                                        }, {\n\t                                            on: on,\n\t                                            send: send\n\t                                        });\n\t                                    }\n\t                                }));\n\t                            }(event, {\n\t                                on: on,\n\t                                send: send\n\t                            });\n\t                        }));\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t                !function(_ref8) {\n\t                    var on = _ref8.on, send = _ref8.send;\n\t                    globalStore(\"builtinListeners\").getOrSet(\"helloListener\", (function() {\n\t                        var listener = on(\"postrobot_hello\", {\n\t                            domain: \"*\"\n\t                        }, (function(_ref3) {\n\t                            resolveHelloPromise(_ref3.source, {\n\t                                domain: _ref3.origin\n\t                            });\n\t                            return {\n\t                                instanceID: getInstanceID()\n\t                            };\n\t                        }));\n\t                        var parent = getAncestor();\n\t                        parent && sayHello(parent, {\n\t                            send: send\n\t                        }).catch((function(err) {}));\n\t                        return listener;\n\t                    }));\n\t                }({\n\t                    on: on_on,\n\t                    send: send_send\n\t                });\n\t            }\n\t            var _ref3, on, send, global;\n\t        }\n\t        function destroy() {\n\t            !function() {\n\t                var responseListeners = globalStore(\"responseListeners\");\n\t                for (var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++) {\n\t                    var hash = _responseListeners$ke2[_i2];\n\t                    var listener = responseListeners.get(hash);\n\t                    listener && (listener.cancelled = true);\n\t                    responseListeners.del(hash);\n\t                }\n\t            }();\n\t            (listener = globalStore().get(\"postMessageListener\")) && listener.cancel();\n\t            var listener;\n\t            delete window.__post_robot_10_0_46__;\n\t        }\n\t        var src_types_TYPES_0 = true;\n\t        function cleanUpWindow(win) {\n\t            for (var _i2 = 0, _requestPromises$get2 = windowStore(\"requestPromises\").get(win, []); _i2 < _requestPromises$get2.length; _i2++) _requestPromises$get2[_i2].reject(new Error(\"Window \" + (isWindowClosed(win) ? \"closed\" : \"cleaned up\") + \" before response\")).catch(src_util_noop);\n\t        }\n\t        setup();\n\t    } ]);\n\t})); \n} (postRobot));\n\nvar postRobotExports$1 = postRobot.exports;\n\n/* @flow */\n\n(function (module) {\n\t// $FlowFixMe\n\tmodule.exports = postRobotExports$1; // eslint-disable-line import/no-commonjs\n\n\t// $FlowFixMe\n\tmodule.exports.default = module.exports; // eslint-disable-line import/no-commonjs \n} (postRobot$1));\n\nvar postRobotExports = postRobot$1.exports;\nvar index = /*@__PURE__*/getDefaultExportFromCjs(postRobotExports);\n\nvar index$1 = /*#__PURE__*/_mergeNamespaces({\n\t__proto__: null,\n\tdefault: index\n}, [postRobotExports]);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9mYW1pbHkvbGliL2luZGV4LUNzLW9ubnR2LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxrQkFBa0IsK0JBQW1CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSwrQkFBbUI7QUFDL0Y7QUFDQTtBQUNBO0FBQ0EsU0FBUywrQkFBbUI7QUFDNUIsU0FBUywrQkFBbUI7QUFDNUIsU0FBUywrQkFBbUI7QUFDNUIsYUFBYSwrQkFBbUI7QUFDaEM7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCLGtDQUFrQywrQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsYUFBYSwrQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLDhFQUE4RSwrQkFBbUI7QUFDakc7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLFNBQVMsK0JBQW1CO0FBQzVCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWEsK0JBQW1CO0FBQ2hDO0FBQ0E7QUFDQSxTQUFTLCtCQUFtQjtBQUM1QixzQkFBc0I7QUFDdEI7QUFDQSxTQUFTLCtCQUFtQjtBQUM1QixnQkFBZ0IsK0JBQW1CLENBQUMsK0JBQW1CO0FBQ3ZELE1BQU0sb0JBQW9CLDBCQUFtQixFQUFFLCtCQUFtQjtBQUNsRSxTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRCxTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQjtBQUNsRDtBQUNBLFVBQVU7QUFDVixTQUFTLCtCQUFtQixHQUFHLDBCQUFtQiwwQkFBMEI7QUFDNUU7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsNkJBQTZCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxrQ0FBa0M7QUFDbEMsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsMEJBQTBCO0FBQzFCLHNCQUFzQjtBQUN0QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5QkFBeUI7QUFDbkQ7QUFDQSxzQkFBc0I7QUFDdEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLHFDQUFxQztBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRyxvQ0FBb0M7QUFDeEk7QUFDQTtBQUNBLE9BQU87QUFDUCxFQUFFO0FBQ0YsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBLDBDQUEwQztBQUMxQyxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFdUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9lbGVtZW4vc29saWRpdHkvTGVuZGluZy1Qcm90b2NvbC9mcm9udGVuZC9ub2RlX21vZHVsZXMvZmFtaWx5L2xpYi9pbmRleC1Dcy1vbm50di5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcblx0bS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG5cdFx0ZSAmJiB0eXBlb2YgZSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoZSkgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdFx0aWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhKGsgaW4gbikpIHtcblx0XHRcdFx0dmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9KTtcblx0cmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBjb21tb25qc0dsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZiA6IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyAoeCkge1xuXHRyZXR1cm4geCAmJiB4Ll9fZXNNb2R1bGUgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdkZWZhdWx0JykgPyB4WydkZWZhdWx0J10gOiB4O1xufVxuXG52YXIgcG9zdFJvYm90JDEgPSB7ZXhwb3J0czoge319O1xuXG52YXIgcG9zdFJvYm90ID0ge2V4cG9ydHM6IHt9fTtcblxuKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcblx0IWZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0ICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDtcblx0fShcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBzZWxmID8gc2VsZiA6IGNvbW1vbmpzR2xvYmFsLCAoZnVuY3Rpb24oKSB7XG5cdCAgICByZXR1cm4gZnVuY3Rpb24obW9kdWxlcykge1xuXHQgICAgICAgIHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cdCAgICAgICAgZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQgICAgICAgICAgICBpZiAoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXHQgICAgICAgICAgICB2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG5cdCAgICAgICAgICAgICAgICBpOiBtb2R1bGVJZCxcblx0ICAgICAgICAgICAgICAgIGw6IGZhbHNlLFxuXHQgICAgICAgICAgICAgICAgZXhwb3J0czoge31cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgbW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cdCAgICAgICAgICAgIG1vZHVsZS5sID0gdHJ1ZTtcblx0ICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSB8fCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuXHQgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgIGdldDogZ2V0dGVyXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuXHQgICAgICAgICAgICBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgU3ltYm9sLnRvU3RyaW5nVGFnICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiBcIk1vZHVsZVwiXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcblx0ICAgICAgICAgICAgMSAmIG1vZGUgJiYgKHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSkpO1xuXHQgICAgICAgICAgICBpZiAoOCAmIG1vZGUpIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgaWYgKDQgJiBtb2RlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgdmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0ICAgICAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcblx0ICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCBcImRlZmF1bHRcIiwge1xuXHQgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcblx0ICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgaWYgKDIgJiBtb2RlICYmIFwic3RyaW5nXCIgIT0gdHlwZW9mIHZhbHVlKSBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuXHQgICAgICAgICAgICB9LmJpbmQobnVsbCwga2V5KSk7XG5cdCAgICAgICAgICAgIHJldHVybiBucztcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHQgICAgICAgICAgICB2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID8gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlLmRlZmF1bHQ7XG5cdCAgICAgICAgICAgIH0gOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGU7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIFwiYVwiLCBnZXR0ZXIpO1xuXHQgICAgICAgICAgICByZXR1cm4gZ2V0dGVyO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHQgICAgICAgICAgICByZXR1cm4ge30uaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cdCAgICAgICAgcmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG5cdCAgICB9KFsgZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlByb21pc2VcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2U7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIlRZUEVTXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNyY190eXBlc19UWVBFU18wO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJQcm94eVdpbmRvd1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3c7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNldHVwXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldHVwO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJkZXN0cm95XCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGRlc3Ryb3k7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNlcmlhbGl6ZU1lc3NhZ2VcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0dXBfc2VyaWFsaXplTWVzc2FnZTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZGVzZXJpYWxpemVNZXNzYWdlXCIsIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldHVwX2Rlc2VyaWFsaXplTWVzc2FnZTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3JlYXRlUHJveHlXaW5kb3dcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gY3JlYXRlUHJveHlXaW5kb3c7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRvUHJveHlXaW5kb3dcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0dXBfdG9Qcm94eVdpbmRvdztcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib25cIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gb25fb247XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9uY2VcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gb25fb25jZTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwic2VuZFwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBzZW5kX3NlbmQ7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm1hcmtXaW5kb3dLbm93blwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBtYXJrV2luZG93S25vd247XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImNsZWFuVXBXaW5kb3dcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICByZXR1cm4gY2xlYW5VcFdpbmRvdztcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYnJpZGdlXCIsIChmdW5jdGlvbigpIHt9KSk7XG5cdCAgICAgICAgZnVuY3Rpb24gaXNSZWdleChpdGVtKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgUmVnRXhwXVwiID09PSB7fS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgSUVfV0lOX0FDQ0VTU19FUlJPUiA9IFwiQ2FsbCB3YXMgcmVqZWN0ZWQgYnkgY2FsbGVlLlxcclxcblwiO1xuXHQgICAgICAgIGZ1bmN0aW9uIGdldEFjdHVhbFByb3RvY29sKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbi5sb2NhdGlvbi5wcm90b2NvbDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0UHJvdG9jb2wod2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICBpZiAod2luLm1vY2tEb21haW4pIHtcblx0ICAgICAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IHdpbi5tb2NrRG9tYWluLnNwbGl0KFwiLy9cIilbMF07XG5cdCAgICAgICAgICAgICAgICBpZiAocHJvdG9jb2wpIHJldHVybiBwcm90b2NvbDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZ2V0QWN0dWFsUHJvdG9jb2wod2luKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNBYm91dFByb3RvY29sKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgcmV0dXJuIFwiYWJvdXQ6XCIgPT09IGdldFByb3RvY29sKHdpbik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFBhcmVudCh3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIGlmICh3aW4pIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luLnBhcmVudCAmJiB3aW4ucGFyZW50ICE9PSB3aW4pIHJldHVybiB3aW4ucGFyZW50O1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldE9wZW5lcih3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIGlmICh3aW4gJiYgIWdldFBhcmVudCh3aW4pKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHdpbi5vcGVuZXI7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gY2FuUmVhZEZyb21XaW5kb3cod2luKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRBY3R1YWxEb21haW4od2luKSB7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gd2luICYmICh3aW4gPSB3aW5kb3cpO1xuXHQgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSB3aW4ubG9jYXRpb247XG5cdCAgICAgICAgICAgIGlmICghbG9jYXRpb24pIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVhZCB3aW5kb3cgbG9jYXRpb25cIik7XG5cdCAgICAgICAgICAgIHZhciBwcm90b2NvbCA9IGdldEFjdHVhbFByb3RvY29sKHdpbik7XG5cdCAgICAgICAgICAgIGlmICghcHJvdG9jb2wpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVhZCB3aW5kb3cgcHJvdG9jb2xcIik7XG5cdCAgICAgICAgICAgIGlmIChcImZpbGU6XCIgPT09IHByb3RvY29sKSByZXR1cm4gXCJmaWxlOi8vXCI7XG5cdCAgICAgICAgICAgIGlmIChcImFib3V0OlwiID09PSBwcm90b2NvbCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IGdldFBhcmVudCh3aW4pO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudCAmJiBjYW5SZWFkRnJvbVdpbmRvdygpID8gZ2V0QWN0dWFsRG9tYWluKHBhcmVudCkgOiBcImFib3V0Oi8vXCI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIGhvc3QgPSBsb2NhdGlvbi5ob3N0O1xuXHQgICAgICAgICAgICBpZiAoIWhvc3QpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcmVhZCB3aW5kb3cgaG9zdFwiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb3RvY29sICsgXCIvL1wiICsgaG9zdDtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RG9tYWluKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgdmFyIGRvbWFpbiA9IGdldEFjdHVhbERvbWFpbih3aW4pO1xuXHQgICAgICAgICAgICByZXR1cm4gZG9tYWluICYmIHdpbi5tb2NrRG9tYWluICYmIDAgPT09IHdpbi5tb2NrRG9tYWluLmluZGV4T2YoXCJtb2NrOlwiKSA/IHdpbi5tb2NrRG9tYWluIDogZG9tYWluO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc1NhbWVEb21haW4od2luKSB7XG5cdCAgICAgICAgICAgIGlmICghZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICh3aW4gPT09IHdpbmRvdykgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luLCBcImxvY2F0aW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChkZXNjICYmICExID09PSBkZXNjLmVudW1lcmFibGUpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWJvdXRQcm90b2NvbCh3aW4pICYmIGNhblJlYWRGcm9tV2luZG93KCkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwibW9jazpcIiA9PT0gZ2V0UHJvdG9jb2wod2luKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KHdpbikgJiYgY2FuUmVhZEZyb21XaW5kb3coKSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0QWN0dWFsRG9tYWluKHdpbikgPT09IGdldEFjdHVhbERvbWFpbih3aW5kb3cpKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH0od2luKSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbiA9PT0gd2luZG93KSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNBYm91dFByb3RvY29sKHdpbikgJiYgY2FuUmVhZEZyb21XaW5kb3coKSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICAgICAgaWYgKGdldERvbWFpbih3aW5kb3cpID09PSBnZXREb21haW4od2luKSkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gYXNzZXJ0U2FtZURvbWFpbih3aW4pIHtcblx0ICAgICAgICAgICAgaWYgKCFpc1NhbWVEb21haW4od2luKSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgd2luZG93IHRvIGJlIHNhbWUgZG9tYWluXCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gd2luO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc0FuY2VzdG9yUGFyZW50KHBhcmVudCwgY2hpbGQpIHtcblx0ICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgIWNoaWxkKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIHZhciBjaGlsZFBhcmVudCA9IGdldFBhcmVudChjaGlsZCk7XG5cdCAgICAgICAgICAgIHJldHVybiBjaGlsZFBhcmVudCA/IGNoaWxkUGFyZW50ID09PSBwYXJlbnQgOiAtMSAhPT0gZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAoO3dpbi5wYXJlbnQgIT09IHdpbjsgKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHdpbi5wYXJlbnQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW4gPSB3aW4ucGFyZW50O1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH0oY2hpbGQpLmluZGV4T2YocGFyZW50KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RnJhbWVzKHdpbikge1xuXHQgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cdCAgICAgICAgICAgIHZhciBmcmFtZXM7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBmcmFtZXMgPSB3aW4uZnJhbWVzO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGZyYW1lcyA9IHdpbjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgbGVuO1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgbGVuID0gZnJhbWVzLmxlbmd0aDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICBpZiAoMCA9PT0gbGVuKSByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICBpZiAobGVuKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lID0gZnJhbWVzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZnJhbWUpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgMTAwOyBfaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBfZnJhbWUgPSBmcmFtZXNbX2ldO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICghX2ZyYW1lKSByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goX2ZyYW1lKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgaWZyYW1lV2luZG93cyA9IFtdO1xuXHQgICAgICAgIHZhciBpZnJhbWVGcmFtZXMgPSBbXTtcblx0ICAgICAgICBmdW5jdGlvbiBpc1dpbmRvd0Nsb3NlZCh3aW4sIGFsbG93TW9jaykge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGFsbG93TW9jayAmJiAoYWxsb3dNb2NrID0gdHJ1ZSk7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luID09PSB3aW5kb3cpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCF3aW4pIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbi5jbG9zZWQpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gIWVyciB8fCBlcnIubWVzc2FnZSAhPT0gSUVfV0lOX0FDQ0VTU19FUlJPUjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBpZiAoYWxsb3dNb2NrICYmIGlzU2FtZURvbWFpbih3aW4pKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKHdpbi5tb2NrY2xvc2VkKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICghd2luLnBhcmVudCB8fCAhd2luLnRvcCkgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIHZhciBpZnJhbWVJbmRleCA9IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZW0pIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sbGVjdGlvbi5sZW5ndGg7IGkrKykgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGlvbltpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG5cdCAgICAgICAgICAgIH0oaWZyYW1lV2luZG93cywgd2luKTtcblx0ICAgICAgICAgICAgaWYgKC0xICE9PSBpZnJhbWVJbmRleCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gaWZyYW1lRnJhbWVzW2lmcmFtZUluZGV4XTtcblx0ICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiBmdW5jdGlvbihmcmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghZnJhbWUuY29udGVudFdpbmRvdykgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFmcmFtZS5wYXJlbnROb2RlKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gZnJhbWUub3duZXJEb2N1bWVudDtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoZG9jICYmIGRvYy5kb2N1bWVudEVsZW1lbnQgJiYgIWRvYy5kb2N1bWVudEVsZW1lbnQuY29udGFpbnMoZnJhbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBmcmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZm9yICg7cGFyZW50LnBhcmVudE5vZGUgJiYgcGFyZW50LnBhcmVudE5vZGUgIT09IHBhcmVudDsgKSBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJlbnQuaG9zdCB8fCAhZG9jLmRvY3VtZW50RWxlbWVudC5jb250YWlucyhwYXJlbnQuaG9zdCkpIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9KGZyYW1lKSkgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRBbmNlc3Rvcih3aW4pIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSB3aW4gJiYgKHdpbiA9IHdpbmRvdyk7XG5cdCAgICAgICAgICAgIHJldHVybiBnZXRPcGVuZXIod2luID0gd2luIHx8IHdpbmRvdykgfHwgZ2V0UGFyZW50KHdpbikgfHwgdm9pZCAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBtYXRjaERvbWFpbihwYXR0ZXJuLCBvcmlnaW4pIHtcblx0ICAgICAgICAgICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHBhdHRlcm4pIHtcblx0ICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiBvcmlnaW4pIHJldHVybiBcIipcIiA9PT0gcGF0dGVybiB8fCBvcmlnaW4gPT09IHBhdHRlcm47XG5cdCAgICAgICAgICAgICAgICBpZiAoaXNSZWdleChvcmlnaW4pKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcmlnaW4pKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgcmV0dXJuIGlzUmVnZXgocGF0dGVybikgPyBpc1JlZ2V4KG9yaWdpbikgPyBwYXR0ZXJuLnRvU3RyaW5nKCkgPT09IG9yaWdpbi50b1N0cmluZygpIDogIUFycmF5LmlzQXJyYXkob3JpZ2luKSAmJiBCb29sZWFuKG9yaWdpbi5tYXRjaChwYXR0ZXJuKSkgOiAhIUFycmF5LmlzQXJyYXkocGF0dGVybikgJiYgKEFycmF5LmlzQXJyYXkob3JpZ2luKSA/IEpTT04uc3RyaW5naWZ5KHBhdHRlcm4pID09PSBKU09OLnN0cmluZ2lmeShvcmlnaW4pIDogIWlzUmVnZXgob3JpZ2luKSAmJiBwYXR0ZXJuLnNvbWUoKGZ1bmN0aW9uKHN1YnBhdHRlcm4pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaERvbWFpbihzdWJwYXR0ZXJuLCBvcmlnaW4pO1xuXHQgICAgICAgICAgICB9KSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc1dpbmRvdyhvYmopIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmogPT09IHdpbmRvdykgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgZXJyLm1lc3NhZ2UgPT09IElFX1dJTl9BQ0NFU1NfRVJST1IpIHJldHVybiB0cnVlO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJbb2JqZWN0IFdpbmRvd11cIiA9PT0ge30udG9TdHJpbmcuY2FsbChvYmopKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuV2luZG93ICYmIG9iaiBpbnN0YW5jZW9mIHdpbmRvdy5XaW5kb3cpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlID09PSBJRV9XSU5fQUNDRVNTX0VSUk9SKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9iaiAmJiBvYmouc2VsZiA9PT0gb2JqKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnBhcmVudCA9PT0gb2JqKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLnRvcCA9PT0gb2JqKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gSUVfV0lOX0FDQ0VTU19FUlJPUikgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChvYmogJiYgXCJfX3VubGlrZWx5X3ZhbHVlX19cIiA9PT0gb2JqLl9fY3Jvc3NfZG9tYWluX3V0aWxzX3dpbmRvd19jaGVja19fKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGlmIChcInBvc3RNZXNzYWdlXCIgaW4gb2JqICYmIFwic2VsZlwiIGluIG9iaiAmJiBcImxvY2F0aW9uXCIgaW4gb2JqKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFtZUZvcldpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSByZXR1cm4gYXNzZXJ0U2FtZURvbWFpbih3aW4pLmZyYW1lRWxlbWVudDtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kyMSA9IDAsIF9kb2N1bWVudCRxdWVyeVNlbGVjdDIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiaWZyYW1lXCIpOyBfaTIxIDwgX2RvY3VtZW50JHF1ZXJ5U2VsZWN0Mi5sZW5ndGg7IF9pMjErKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGZyYW1lID0gX2RvY3VtZW50JHF1ZXJ5U2VsZWN0MltfaTIxXTtcblx0ICAgICAgICAgICAgICAgIGlmIChmcmFtZSAmJiBmcmFtZS5jb250ZW50V2luZG93ICYmIGZyYW1lLmNvbnRlbnRXaW5kb3cgPT09IHdpbikgcmV0dXJuIGZyYW1lO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGNsb3NlV2luZG93KHdpbikge1xuXHQgICAgICAgICAgICBpZiAoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBCb29sZWFuKGdldFBhcmVudCh3aW4pKTtcblx0ICAgICAgICAgICAgfSh3aW4pKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBnZXRGcmFtZUZvcldpbmRvdyh3aW4pO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZyYW1lICYmIGZyYW1lLnBhcmVudEVsZW1lbnQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBmcmFtZS5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGZyYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHdpbi5jbG9zZSgpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHV0aWxzX2lzUHJvbWlzZShpdGVtKSB7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWl0ZW0pIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBQcm9taXNlICYmIGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSByZXR1cm4gITA7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2Ygd2luZG93ICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygd2luZG93LldpbmRvdyAmJiBpdGVtIGluc3RhbmNlb2Ygd2luZG93LldpbmRvdykgcmV0dXJuICExO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIHdpbmRvdyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHdpbmRvdy5jb25zdHJ1Y3RvciAmJiBpdGVtIGluc3RhbmNlb2Ygd2luZG93LmNvbnN0cnVjdG9yKSByZXR1cm4gITE7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICBpZiAoX3RvU3RyaW5nKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfdG9TdHJpbmcuY2FsbChpdGVtKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoXCJbb2JqZWN0IFdpbmRvd11cIiA9PT0gbmFtZSB8fCBcIltvYmplY3QgZ2xvYmFsXVwiID09PSBuYW1lIHx8IFwiW29iamVjdCBET01XaW5kb3ddXCIgPT09IG5hbWUpIHJldHVybiAhMTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZW0udGhlbikgcmV0dXJuICEwO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBkaXNwYXRjaGVkRXJyb3JzID0gW107XG5cdCAgICAgICAgdmFyIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzID0gW107XG5cdCAgICAgICAgdmFyIGFjdGl2ZUNvdW50ID0gMDtcblx0ICAgICAgICB2YXIgZmx1c2hQcm9taXNlO1xuXHQgICAgICAgIGZ1bmN0aW9uIGZsdXNoQWN0aXZlKCkge1xuXHQgICAgICAgICAgICBpZiAoIWFjdGl2ZUNvdW50ICYmIGZsdXNoUHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmbHVzaFByb21pc2U7XG5cdCAgICAgICAgICAgICAgICBmbHVzaFByb21pc2UgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKCk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc3RhcnRBY3RpdmUoKSB7XG5cdCAgICAgICAgICAgIGFjdGl2ZUNvdW50ICs9IDE7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGVuZEFjdGl2ZSgpIHtcblx0ICAgICAgICAgICAgYWN0aXZlQ291bnQgLT0gMTtcblx0ICAgICAgICAgICAgZmx1c2hBY3RpdmUoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHByb21pc2VfWmFsZ29Qcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIFphbGdvUHJvbWlzZShoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ZWQgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVycyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hpbmcgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RlZCA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5lcnJvckhhbmRsZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcblx0ICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9lcnJvcjtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWQgPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaXNBc3luYyA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHN0YXJ0QWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcigoZnVuY3Rpb24ocmVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luYykgX3RoaXMucmVzb2x2ZShyZXMpOyBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZCA9ICEwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQgPSByZXM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3luYykgX3RoaXMucmVqZWN0KGVycik7IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdGVkID0gITA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Vycm9yID0gZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlzQXN5bmMgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkID8gdGhpcy5yZXNvbHZlKF9yZXN1bHQpIDogcmVqZWN0ZWQgJiYgdGhpcy5yZWplY3QoX2Vycm9yKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgX3Byb3RvID0gWmFsZ29Qcm9taXNlLnByb3RvdHlwZTtcblx0ICAgICAgICAgICAgX3Byb3RvLnJlc29sdmUgPSBmdW5jdGlvbihyZXN1bHQpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVkIHx8IHRoaXMucmVqZWN0ZWQpIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICAgICAgaWYgKHV0aWxzX2lzUHJvbWlzZShyZXN1bHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IHJlc29sdmUgcHJvbWlzZSB3aXRoIGFub3RoZXIgcHJvbWlzZVwiKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZWQgPSB0cnVlO1xuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8ucmVqZWN0ID0gZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMucmVzb2x2ZWQgfHwgdGhpcy5yZWplY3RlZCkgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgICAgICBpZiAodXRpbHNfaXNQcm9taXNlKGVycm9yKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCByZWplY3QgcHJvbWlzZSB3aXRoIGFub3RoZXIgcHJvbWlzZVwiKTtcblx0ICAgICAgICAgICAgICAgIGlmICghZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgX2VyciA9IGVycm9yICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZXJyb3IudG9TdHJpbmcgPyBlcnJvci50b1N0cmluZygpIDoge30udG9TdHJpbmcuY2FsbChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJFeHBlY3RlZCByZWplY3QgdG8gYmUgY2FsbGVkIHdpdGggRXJyb3IsIGdvdCBcIiArIF9lcnIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdGhpcy5yZWplY3RlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9yID0gZXJyb3I7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCB8fCBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpczIuZXJyb3JIYW5kbGVkIHx8IGZ1bmN0aW9uKGVyciwgcHJvbWlzZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLTEgPT09IGRpc3BhdGNoZWRFcnJvcnMuaW5kZXhPZihlcnIpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXNwYXRjaGVkRXJyb3JzLnB1c2goZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zc2libHlVbmhhbmRsZWRQcm9taXNlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzW2pdKGVyciwgcHJvbWlzZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KGVycm9yLCBfdGhpczIpO1xuXHQgICAgICAgICAgICAgICAgfSksIDEpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCgpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5hc3luY1JlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmRpc3BhdGNoID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSB0aGlzLnJlc29sdmVkLCByZWplY3RlZCA9IHRoaXMucmVqZWN0ZWQsIGhhbmRsZXJzID0gdGhpcy5oYW5kbGVycztcblx0ICAgICAgICAgICAgICAgIGlmICghdGhpcy5kaXNwYXRjaGluZyAmJiAocmVzb2x2ZWQgfHwgcmVqZWN0ZWQpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgc3RhcnRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgY2hhaW4gPSBmdW5jdGlvbihmaXJzdFByb21pc2UsIHNlY29uZFByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0UHJvbWlzZS50aGVuKChmdW5jdGlvbihyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFByb21pc2UucmVzb2x2ZShyZXMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vjb25kUHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2hhbmRsZXJzJGkgPSBoYW5kbGVyc1tpXSwgb25TdWNjZXNzID0gX2hhbmRsZXJzJGkub25TdWNjZXNzLCBvbkVycm9yID0gX2hhbmRsZXJzJGkub25FcnJvciwgcHJvbWlzZSA9IF9oYW5kbGVycyRpLnByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfcmVzdWx0MiA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3VsdDIgPSBvblN1Y2Nlc3MgPyBvblN1Y2Nlc3ModGhpcy52YWx1ZSkgOiB0aGlzLnZhbHVlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWplY3RlZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvbkVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QodGhpcy5lcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQyID0gb25FcnJvcih0aGlzLmVycm9yKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXN1bHQyIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlICYmIChfcmVzdWx0Mi5yZXNvbHZlZCB8fCBfcmVzdWx0Mi5yZWplY3RlZCkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlUmVzdWx0ID0gX3Jlc3VsdDI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzdWx0LnJlc29sdmVkID8gcHJvbWlzZS5yZXNvbHZlKHByb21pc2VSZXN1bHQudmFsdWUpIDogcHJvbWlzZS5yZWplY3QocHJvbWlzZVJlc3VsdC5lcnJvcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlUmVzdWx0LmVycm9ySGFuZGxlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB1dGlsc19pc1Byb21pc2UoX3Jlc3VsdDIpID8gX3Jlc3VsdDIgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UgJiYgKF9yZXN1bHQyLnJlc29sdmVkIHx8IF9yZXN1bHQyLnJlamVjdGVkKSA/IF9yZXN1bHQyLnJlc29sdmVkID8gcHJvbWlzZS5yZXNvbHZlKF9yZXN1bHQyLnZhbHVlKSA6IHByb21pc2UucmVqZWN0KF9yZXN1bHQyLmVycm9yKSA6IGNoYWluKF9yZXN1bHQyLCBwcm9taXNlKSA6IHByb21pc2UucmVzb2x2ZShfcmVzdWx0Mik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzLmxlbmd0aCA9IDA7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaGluZyA9IGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIGVuZEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8udGhlbiA9IGZ1bmN0aW9uKG9uU3VjY2Vzcywgb25FcnJvcikge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9uU3VjY2VzcyAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9uU3VjY2VzcyAmJiAhb25TdWNjZXNzLmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UudGhlbiBleHBlY3RlZCBhIGZ1bmN0aW9uIGZvciBzdWNjZXNzIGhhbmRsZXJcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAob25FcnJvciAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9uRXJyb3IgJiYgIW9uRXJyb3IuY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZS50aGVuIGV4cGVjdGVkIGEgZnVuY3Rpb24gZm9yIGVycm9yIGhhbmRsZXJcIik7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuXHQgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2UsXG5cdCAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzOiBvblN1Y2Nlc3MsXG5cdCAgICAgICAgICAgICAgICAgICAgb25FcnJvcjogb25FcnJvclxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmNhdGNoID0gZnVuY3Rpb24ob25FcnJvcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbih2b2lkIDAsIG9uRXJyb3IpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZmluYWxseSA9IGZ1bmN0aW9uKG9uRmluYWxseSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG9uRmluYWxseSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIG9uRmluYWxseSAmJiAhb25GaW5hbGx5LmNhbGwpIHRocm93IG5ldyBFcnJvcihcIlByb21pc2UuZmluYWxseSBleHBlY3RlZCBhIGZ1bmN0aW9uXCIpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbigoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS50cnkob25GaW5hbGx5KS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSwgKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UudHJ5KG9uRmluYWxseSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by50aW1lb3V0ID0gZnVuY3Rpb24odGltZSwgZXJyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc29sdmVkIHx8IHRoaXMucmVqZWN0ZWQpIHJldHVybiB0aGlzO1xuXHQgICAgICAgICAgICAgICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBfdGhpczMucmVzb2x2ZWQgfHwgX3RoaXMzLnJlamVjdGVkIHx8IF90aGlzMy5yZWplY3QoZXJyIHx8IG5ldyBFcnJvcihcIlByb21pc2UgdGltZWQgb3V0IGFmdGVyIFwiICsgdGltZSArIFwibXNcIikpO1xuXHQgICAgICAgICAgICAgICAgfSksIHRpbWUpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudGhlbigoZnVuY3Rpb24ocmVzdWx0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by50b1Byb21pc2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBQcm9taXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ291bGQgbm90IGZpbmQgUHJvbWlzZVwiKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcyk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5sYXp5ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmVycm9ySGFuZGxlZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlID8gdmFsdWUgOiB1dGlsc19pc1Byb21pc2UodmFsdWUpID8gbmV3IFphbGdvUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblx0ICAgICAgICAgICAgICAgIH0pKSA6IChuZXcgWmFsZ29Qcm9taXNlKS5yZXNvbHZlKHZhbHVlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBaYWxnb1Byb21pc2UpLnJlamVjdChlcnJvcik7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5hc3luY1JlamVjdCA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBaYWxnb1Byb21pc2UpLmFzeW5jUmVqZWN0KGVycm9yKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmFsbCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBaYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgICAgICB2YXIgY291bnQgPSBwcm9taXNlcy5sZW5ndGg7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0cyA9IFtdLnNsaWNlKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWNvdW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGNoYWluID0gZnVuY3Rpb24oaSwgZmlyc3RQcm9taXNlLCBzZWNvbmRQcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcnN0UHJvbWlzZS50aGVuKChmdW5jdGlvbihyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHJlcztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgMCA9PSAoY291bnQgLT0gMSkgJiYgcHJvbWlzZS5yZXNvbHZlKHJlc3VsdHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlY29uZFByb21pc2UucmVqZWN0KGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbSA9IHByb21pc2VzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChwcm9tIGluc3RhbmNlb2YgWmFsZ29Qcm9taXNlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9tLnJlc29sdmVkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gcHJvbS52YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50IC09IDE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXV0aWxzX2lzUHJvbWlzZShwcm9tKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzW2ldID0gcHJvbTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgLT0gMTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIGNoYWluKGksIFphbGdvUHJvbWlzZS5yZXNvbHZlKHByb20pLCBwcm9taXNlKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIDAgPT09IGNvdW50ICYmIHByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UuaGFzaCA9IGZ1bmN0aW9uKHByb21pc2VzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0ge307XG5cdCAgICAgICAgICAgICAgICB2YXIgYXdhaXRQcm9taXNlcyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24oa2V5KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb21pc2VzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvbWlzZXNba2V5XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdXRpbHNfaXNQcm9taXNlKHZhbHVlKSA/IGF3YWl0UHJvbWlzZXMucHVzaCh2YWx1ZS50aGVuKChmdW5jdGlvbihyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gcmVzO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSkpIDogcmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHByb21pc2VzKSBfbG9vcChrZXkpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFphbGdvUHJvbWlzZS5hbGwoYXdhaXRQcm9taXNlcykudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLm1hcCA9IGZ1bmN0aW9uKGl0ZW1zLCBtZXRob2QpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2UuYWxsKGl0ZW1zLm1hcChtZXRob2QpKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLm9uUG9zc2libHlVbmhhbmRsZWRFeGNlcHRpb24gPSBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaGFuZGxlcikge1xuXHQgICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLnB1c2goaGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5VW5oYW5kbGVkUHJvbWlzZUhhbmRsZXJzLnNwbGljZShwb3NzaWJseVVuaGFuZGxlZFByb21pc2VIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpLCAxKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9KGhhbmRsZXIpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBaYWxnb1Byb21pc2UudHJ5ID0gZnVuY3Rpb24obWV0aG9kLCBjb250ZXh0LCBhcmdzKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAobWV0aG9kICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgbWV0aG9kICYmICFtZXRob2QuY2FsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbWlzZS50cnkgZXhwZWN0ZWQgYSBmdW5jdGlvblwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XG5cdCAgICAgICAgICAgICAgICBzdGFydEFjdGl2ZSgpO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBtZXRob2QuYXBwbHkoY29udGV4dCwgYXJncyB8fCBbXSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbmRBY3RpdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnJlamVjdChlcnIpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgZW5kQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gWmFsZ29Qcm9taXNlLnJlc29sdmUocmVzdWx0KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmRlbGF5ID0gZnVuY3Rpb24oX2RlbGF5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFphbGdvUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgX2RlbGF5KTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgWmFsZ29Qcm9taXNlLmlzUHJvbWlzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBaYWxnb1Byb21pc2UpIHx8IHV0aWxzX2lzUHJvbWlzZSh2YWx1ZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFphbGdvUHJvbWlzZS5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKFphbGdvKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHByb21pc2UgPSBmbHVzaFByb21pc2UgPSBmbHVzaFByb21pc2UgfHwgbmV3IFphbGdvO1xuXHQgICAgICAgICAgICAgICAgICAgIGZsdXNoQWN0aXZlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICB9KFphbGdvUHJvbWlzZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiBaYWxnb1Byb21pc2U7XG5cdCAgICAgICAgfSgpO1xuXHQgICAgICAgIGZ1bmN0aW9uIHV0aWxfc2FmZUluZGV4T2YoY29sbGVjdGlvbiwgaXRlbSkge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24ubGVuZ3RoOyBpKyspIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoY29sbGVjdGlvbltpXSA9PT0gaXRlbSkgcmV0dXJuIGk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgcmV0dXJuIC0xO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIENyb3NzRG9tYWluU2FmZVdlYWtNYXAoKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLndlYWttYXAgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmtleXMgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IFwiX193ZWFrbWFwX1wiICsgKDFlOSAqIE1hdGgucmFuZG9tKCkgPj4+IDApICsgXCJfX1wiO1xuXHQgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChcInVuZGVmaW5lZFwiID09IHR5cGVvZiBXZWFrTWFwKSByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gT2JqZWN0LmZyZWV6ZSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXN0V2Vha01hcCA9IG5ldyBXZWFrTWFwO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVzdEtleSA9IHt9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKHRlc3RLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ZXN0V2Vha01hcC5zZXQodGVzdEtleSwgXCJfX3Rlc3R2YWx1ZV9fXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJfX3Rlc3R2YWx1ZV9fXCIgPT09IHRlc3RXZWFrTWFwLmdldCh0ZXN0S2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH0oKSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLndlYWttYXAgPSBuZXcgV2Vha01hcDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMua2V5cyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgX3Byb3RvID0gQ3Jvc3NEb21haW5TYWZlV2Vha01hcC5wcm90b3R5cGU7XG5cdCAgICAgICAgICAgIF9wcm90by5fY2xlYW51cENsb3NlZFdpbmRvd3MgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBrZXlzW2ldO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvdyh2YWx1ZSkgJiYgaXNXaW5kb3dDbG9zZWQodmFsdWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ZWFrbWFwKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2Vha21hcC5kZWxldGUodmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGtleXMuc3BsaWNlKGksIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaSwgMSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGkgLT0gMTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5pc1NhZmVUb1JlYWRXcml0ZSA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuICFpc1dpbmRvdyhrZXkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2V0ID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLnNldChrZXksIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBuYW1lID0gdGhpcy5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGtleVtuYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICBlbnRyeSAmJiBlbnRyeVswXSA9PT0ga2V5ID8gZW50cnlbMV0gPSB2YWx1ZSA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShrZXksIG5hbWUsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFsga2V5LCB2YWx1ZSBdLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogITBcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB1dGlsX3NhZmVJbmRleE9mKGtleXMsIGtleSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoLTEgPT09IGluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAod2Vha21hcC5oYXMoa2V5KSkgcmV0dXJuIHdlYWttYXAuZ2V0KGtleSk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTYWZlVG9SZWFkV3JpdGUoa2V5KSkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZW50cnkgPSBrZXlbdGhpcy5uYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSA/IGVudHJ5WzFdIDogdm9pZCAwO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgdGhpcy5fY2xlYW51cENsb3NlZFdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHV0aWxfc2FmZUluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuXHQgICAgICAgICAgICAgICAgaWYgKC0xICE9PSBpbmRleCkgcmV0dXJuIHRoaXMudmFsdWVzW2luZGV4XTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmRlbGV0ZSA9IGZ1bmN0aW9uKGtleSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFrZXkpIHRocm93IG5ldyBFcnJvcihcIldlYWtNYXAgZXhwZWN0ZWQga2V5XCIpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHdlYWttYXAgPSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICBpZiAod2Vha21hcCkgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICB3ZWFrbWFwLmRlbGV0ZShrZXkpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMud2Vha21hcDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU2FmZVRvUmVhZFdyaXRlKGtleSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVudHJ5ID0ga2V5W3RoaXMubmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgZW50cnkgJiYgZW50cnlbMF0gPT09IGtleSAmJiAoZW50cnlbMF0gPSBlbnRyeVsxXSA9IHZvaWQgMCk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwQ2xvc2VkV2luZG93cygpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB1dGlsX3NhZmVJbmRleE9mKGtleXMsIGtleSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoLTEgIT09IGluZGV4KSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzLnNwbGljZShpbmRleCwgMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5oYXMgPSBmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICgha2V5KSB0aHJvdyBuZXcgRXJyb3IoXCJXZWFrTWFwIGV4cGVjdGVkIGtleVwiKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3ZWFrbWFwID0gdGhpcy53ZWFrbWFwO1xuXHQgICAgICAgICAgICAgICAgaWYgKHdlYWttYXApIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHdlYWttYXAuaGFzKGtleSkpIHJldHVybiAhMDtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLndlYWttYXA7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1NhZmVUb1JlYWRXcml0ZShrZXkpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGtleVt0aGlzLm5hbWVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiAhKCFlbnRyeSB8fCBlbnRyeVswXSAhPT0ga2V5KTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgIHRoaXMuX2NsZWFudXBDbG9zZWRXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gLTEgIT09IHV0aWxfc2FmZUluZGV4T2YodGhpcy5rZXlzLCBrZXkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0T3JTZXQgPSBmdW5jdGlvbihrZXksIGdldHRlcikge1xuXHQgICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHJldHVybiB0aGlzLmdldChrZXkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyKCk7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIENyb3NzRG9tYWluU2FmZVdlYWtNYXA7XG5cdCAgICAgICAgfSgpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZ1bmN0aW9uTmFtZShmbikge1xuXHQgICAgICAgICAgICByZXR1cm4gZm4ubmFtZSB8fCBmbi5fX25hbWVfXyB8fCBmbi5kaXNwbGF5TmFtZSB8fCBcImFub255bW91c1wiO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXRGdW5jdGlvbk5hbWUoZm4sIG5hbWUpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZSBmbi5uYW1lO1xuXHQgICAgICAgICAgICAgICAgZm4ubmFtZSA9IG5hbWU7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgZm4uX19uYW1lX18gPSBmbi5kaXNwbGF5TmFtZSA9IG5hbWU7XG5cdCAgICAgICAgICAgIHJldHVybiBmbjtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gdW5pcXVlSUQoKSB7XG5cdCAgICAgICAgICAgIHZhciBjaGFycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuXHQgICAgICAgICAgICByZXR1cm4gXCJ1aWRfXCIgKyBcInh4eHh4eHh4eHhcIi5yZXBsYWNlKC8uL2csIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG5cdCAgICAgICAgICAgIH0pKSArIFwiX1wiICsgZnVuY3Rpb24oc3RyKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBidG9hKSByZXR1cm4gYnRvYShlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC8lKFswLTlBLUZdezJ9KS9nLCAoZnVuY3Rpb24obSwgcDEpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChwMSwgMTYpKTtcblx0ICAgICAgICAgICAgICAgIH0pKSkucmVwbGFjZSgvWz1dL2csIFwiXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIEJ1ZmZlcikgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0ciwgXCJ1dGY4XCIpLnRvU3RyaW5nKFwiYmFzZTY0XCIpLnJlcGxhY2UoL1s9XS9nLCBcIlwiKTtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZmluZCB3aW5kb3cuYnRvYSBvciBCdWZmZXJcIik7XG5cdCAgICAgICAgICAgIH0oKG5ldyBEYXRlKS50b0lTT1N0cmluZygpLnNsaWNlKDExLCAxOSkucmVwbGFjZShcIlRcIiwgXCIuXCIpKS5yZXBsYWNlKC9bXmEtekEtWjAtOV0vZywgXCJcIikudG9Mb3dlckNhc2UoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG9iamVjdElEcztcblx0ICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVBcmdzKGFyZ3MpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShbXS5zbGljZS5jYWxsKGFyZ3MpLCAoZnVuY3Rpb24oc3Via2V5LCB2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWwgPyBcIm1lbW9pemVbXCIgKyBmdW5jdGlvbihvYmopIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0SURzID0gb2JqZWN0SURzIHx8IG5ldyB3ZWFrbWFwX0Nyb3NzRG9tYWluU2FmZVdlYWtNYXA7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChudWxsID09IG9iaiB8fCBcIm9iamVjdFwiICE9IHR5cGVvZiBvYmogJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBvYmopIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb2JqZWN0XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdWlkID0gb2JqZWN0SURzLmdldChvYmopO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXVpZCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdWlkID0gdHlwZW9mIG9iaiArIFwiOlwiICsgdW5pcXVlSUQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iamVjdElEcy5zZXQob2JqLCB1aWQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1aWQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh2YWwpICsgXCJdXCIgOiBcInVuZGVmaW5lZFwiICE9IHR5cGVvZiB3aW5kb3cgJiYgdmFsIGluc3RhbmNlb2Ygd2luZG93LkVsZW1lbnQgfHwgbnVsbCAhPT0gdmFsICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbCAmJiAxID09PSB2YWwubm9kZVR5cGUgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgdmFsLnN0eWxlICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbC5vd25lckRvY3VtZW50ID8ge30gOiB2YWw7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJndW1lbnRzIG5vdCBzZXJpYWxpemFibGUgLS0gY2FuIG5vdCBiZSB1c2VkIHRvIG1lbW9pemVcIik7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0RW1wdHlPYmplY3QoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIG1lbW9pemVHbG9iYWxJbmRleCA9IDA7XG5cdCAgICAgICAgdmFyIG1lbW9pemVHbG9iYWxJbmRleFZhbGlkRnJvbSA9IDA7XG5cdCAgICAgICAgZnVuY3Rpb24gbWVtb2l6ZShtZXRob2QsIG9wdGlvbnMpIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBvcHRpb25zICYmIChvcHRpb25zID0ge30pO1xuXHQgICAgICAgICAgICB2YXIgX29wdGlvbnMkdGhpc05hbWVzcGFjID0gb3B0aW9ucy50aGlzTmFtZXNwYWNlLCB0aGlzTmFtZXNwYWNlID0gdm9pZCAwICE9PSBfb3B0aW9ucyR0aGlzTmFtZXNwYWMgJiYgX29wdGlvbnMkdGhpc05hbWVzcGFjLCBjYWNoZVRpbWUgPSBvcHRpb25zLnRpbWU7XG5cdCAgICAgICAgICAgIHZhciBzaW1wbGVDYWNoZTtcblx0ICAgICAgICAgICAgdmFyIHRoaXNDYWNoZTtcblx0ICAgICAgICAgICAgdmFyIG1lbW9pemVJbmRleCA9IG1lbW9pemVHbG9iYWxJbmRleDtcblx0ICAgICAgICAgICAgbWVtb2l6ZUdsb2JhbEluZGV4ICs9IDE7XG5cdCAgICAgICAgICAgIHZhciBtZW1vaXplZEZ1bmN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG5cdCAgICAgICAgICAgICAgICBpZiAobWVtb2l6ZUluZGV4IDwgbWVtb2l6ZUdsb2JhbEluZGV4VmFsaWRGcm9tKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2ltcGxlQ2FjaGUgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNDYWNoZSA9IG51bGw7XG5cdCAgICAgICAgICAgICAgICAgICAgbWVtb2l6ZUluZGV4ID0gbWVtb2l6ZUdsb2JhbEluZGV4O1xuXHQgICAgICAgICAgICAgICAgICAgIG1lbW9pemVHbG9iYWxJbmRleCArPSAxO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGNhY2hlO1xuXHQgICAgICAgICAgICAgICAgY2FjaGUgPSB0aGlzTmFtZXNwYWNlID8gKHRoaXNDYWNoZSA9IHRoaXNDYWNoZSB8fCBuZXcgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwKS5nZXRPclNldCh0aGlzLCBnZXRFbXB0eU9iamVjdCkgOiBzaW1wbGVDYWNoZSA9IHNpbXBsZUNhY2hlIHx8IHt9O1xuXHQgICAgICAgICAgICAgICAgdmFyIGNhY2hlS2V5O1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBjYWNoZUtleSA9IHNlcmlhbGl6ZUFyZ3MoYXJncyk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChfdW51c2VkKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGNhY2hlUmVzdWx0ID0gY2FjaGVbY2FjaGVLZXldO1xuXHQgICAgICAgICAgICAgICAgaWYgKGNhY2hlUmVzdWx0ICYmIGNhY2hlVGltZSAmJiBEYXRlLm5vdygpIC0gY2FjaGVSZXN1bHQudGltZSA8IGNhY2hlVGltZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjYWNoZVtjYWNoZUtleV07XG5cdCAgICAgICAgICAgICAgICAgICAgY2FjaGVSZXN1bHQgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKGNhY2hlUmVzdWx0KSByZXR1cm4gY2FjaGVSZXN1bHQudmFsdWU7XG5cdCAgICAgICAgICAgICAgICB2YXIgdGltZSA9IERhdGUubm93KCk7XG5cdCAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBtZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgIGNhY2hlW2NhY2hlS2V5XSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICB0aW1lOiB0aW1lLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgbWVtb2l6ZWRGdW5jdGlvbi5yZXNldCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgc2ltcGxlQ2FjaGUgPSBudWxsO1xuXHQgICAgICAgICAgICAgICAgdGhpc0NhY2hlID0gbnVsbDtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgcmV0dXJuIHNldEZ1bmN0aW9uTmFtZShtZW1vaXplZEZ1bmN0aW9uLCAob3B0aW9ucy5uYW1lIHx8IGdldEZ1bmN0aW9uTmFtZShtZXRob2QpKSArIFwiOjptZW1vaXplZFwiKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgbWVtb2l6ZS5jbGVhciA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBtZW1vaXplR2xvYmFsSW5kZXhWYWxpZEZyb20gPSBtZW1vaXplR2xvYmFsSW5kZXg7XG5cdCAgICAgICAgfTtcblx0ICAgICAgICBmdW5jdGlvbiBtZW1vaXplUHJvbWlzZShtZXRob2QpIHtcblx0ICAgICAgICAgICAgdmFyIGNhY2hlID0ge307XG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIG1lbW9pemVkUHJvbWlzZUZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF9hcmd1bWVudHMgPSBhcmd1bWVudHMsIF90aGlzID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuXHQgICAgICAgICAgICAgICAgdmFyIGtleSA9IHNlcmlhbGl6ZUFyZ3MoYXJncyk7XG5cdCAgICAgICAgICAgICAgICBpZiAoY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkgcmV0dXJuIGNhY2hlW2tleV07XG5cdCAgICAgICAgICAgICAgICBjYWNoZVtrZXldID0gcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kLmFwcGx5KF90aGlzLCBfYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgIH0pKS5maW5hbGx5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICBkZWxldGUgY2FjaGVba2V5XTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZVtrZXldO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIG1lbW9pemVkUHJvbWlzZUZ1bmN0aW9uLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBjYWNoZSA9IHt9O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gc2V0RnVuY3Rpb25OYW1lKG1lbW9pemVkUHJvbWlzZUZ1bmN0aW9uLCBnZXRGdW5jdGlvbk5hbWUobWV0aG9kKSArIFwiOjpwcm9taXNlTWVtb2l6ZWRcIik7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNyY191dGlsX25vb3AoKSB7fVxuXHQgICAgICAgIGZ1bmN0aW9uIHN0cmluZ2lmeUVycm9yKGVyciwgbGV2ZWwpIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBsZXZlbCAmJiAobGV2ZWwgPSAxKTtcblx0ICAgICAgICAgICAgaWYgKGxldmVsID49IDMpIHJldHVybiBcInN0cmluZ2lmeUVycm9yIHN0YWNrIG92ZXJmbG93XCI7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIWVycikgcmV0dXJuIFwiPHVua25vd24gZXJyb3I6IFwiICsge30udG9TdHJpbmcuY2FsbChlcnIpICsgXCI+XCI7XG5cdCAgICAgICAgICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgZXJyKSByZXR1cm4gZXJyO1xuXHQgICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrID0gZXJyICYmIGVyci5zdGFjaztcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IGVyciAmJiBlcnIubWVzc2FnZTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2sgJiYgbWVzc2FnZSkgcmV0dXJuIC0xICE9PSBzdGFjay5pbmRleE9mKG1lc3NhZ2UpID8gc3RhY2sgOiBtZXNzYWdlICsgXCJcXG5cIiArIHN0YWNrO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChzdGFjaykgcmV0dXJuIHN0YWNrO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSByZXR1cm4gbWVzc2FnZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHJldHVybiBlcnIgJiYgZXJyLnRvU3RyaW5nICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZXJyLnRvU3RyaW5nID8gZXJyLnRvU3RyaW5nKCkgOiB7fS50b1N0cmluZy5jYWxsKGVycik7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKG5ld0Vycikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIFwiRXJyb3Igd2hpbGUgc3RyaW5naWZ5aW5nIGVycm9yOiBcIiArIHN0cmluZ2lmeUVycm9yKG5ld0VyciwgbGV2ZWwgKyAxKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzdHJpbmdpZnkoaXRlbSkge1xuXHQgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgaXRlbSA/IGl0ZW0gOiBpdGVtLnRvU3RyaW5nICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlbS50b1N0cmluZyA/IGl0ZW0udG9TdHJpbmcoKSA6IHt9LnRvU3RyaW5nLmNhbGwoaXRlbSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIG1lbW9pemUoKGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcykgcmV0dXJuIE9iamVjdC52YWx1ZXMob2JqKTtcblx0ICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiByZXN1bHQucHVzaChvYmpba2V5XSk7XG5cdCAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIGZ1bmN0aW9uIHV0aWxfaXNSZWdleChpdGVtKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBcIltvYmplY3QgUmVnRXhwXVwiID09PSB7fS50b1N0cmluZy5jYWxsKGl0ZW0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiB1dGlsX2dldE9yU2V0KG9iaiwga2V5LCBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSByZXR1cm4gb2JqW2tleV07XG5cdCAgICAgICAgICAgIHZhciB2YWwgPSBnZXR0ZXIoKTtcblx0ICAgICAgICAgICAgb2JqW2tleV0gPSB2YWw7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEJvZHkoKSB7XG5cdCAgICAgICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcblx0ICAgICAgICAgICAgaWYgKCFib2R5KSB0aHJvdyBuZXcgRXJyb3IoXCJCb2R5IGVsZW1lbnQgbm90IGZvdW5kXCIpO1xuXHQgICAgICAgICAgICByZXR1cm4gYm9keTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNEb2N1bWVudFJlYWR5KCkge1xuXHQgICAgICAgICAgICByZXR1cm4gQm9vbGVhbihkb2N1bWVudC5ib2R5KSAmJiBcImNvbXBsZXRlXCIgPT09IGRvY3VtZW50LnJlYWR5U3RhdGU7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGlzRG9jdW1lbnRJbnRlcmFjdGl2ZSgpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oZG9jdW1lbnQuYm9keSkgJiYgXCJpbnRlcmFjdGl2ZVwiID09PSBkb2N1bWVudC5yZWFkeVN0YXRlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBtZW1vaXplKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzRG9jdW1lbnRSZWFkeSgpIHx8IGlzRG9jdW1lbnRJbnRlcmFjdGl2ZSgpKSByZXR1cm4gcmVzb2x2ZSgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gc2V0SW50ZXJ2YWwoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc0RvY3VtZW50UmVhZHkoKSB8fCBpc0RvY3VtZW50SW50ZXJhY3RpdmUoKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9KSwgMTApO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIHZhciBjdXJyZW50U2NyaXB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgZG9jdW1lbnQgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0IDogbnVsbDtcblx0ICAgICAgICB2YXIgZ2V0Q3VycmVudFNjcmlwdCA9IG1lbW9pemUoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBpZiAoY3VycmVudFNjcmlwdCkgcmV0dXJuIGN1cnJlbnRTY3JpcHQ7XG5cdCAgICAgICAgICAgIGlmIChjdXJyZW50U2NyaXB0ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzdGFjayA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyLnN0YWNrIHx8IFwiXCI7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9KCk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0YWNrRGV0YWlscyA9IC8uKmF0IFteKF0qXFwoKC4qKTooLispOiguKylcXCkkL2dpLmV4ZWMoc3RhY2spO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzY3JpcHRMb2NhdGlvbiA9IHN0YWNrRGV0YWlscyAmJiBzdGFja0RldGFpbHNbMV07XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKCFzY3JpcHRMb2NhdGlvbikgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMjIgPSAwLCBfQXJyYXkkcHJvdG90eXBlJHNsaWMyID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKSkucmV2ZXJzZSgpOyBfaTIyIDwgX0FycmF5JHByb3RvdHlwZSRzbGljMi5sZW5ndGg7IF9pMjIrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NyaXB0ID0gX0FycmF5JHByb3RvdHlwZSRzbGljMltfaTIyXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjcmlwdC5zcmMgJiYgc2NyaXB0LnNyYyA9PT0gc2NyaXB0TG9jYXRpb24pIHJldHVybiBzY3JpcHQ7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB9KCkpIHJldHVybiBjdXJyZW50U2NyaXB0O1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4gbm90IGRldGVybWluZSBjdXJyZW50IHNjcmlwdFwiKTtcblx0ICAgICAgICB9KSk7XG5cdCAgICAgICAgdmFyIGN1cnJlbnRVSUQgPSB1bmlxdWVJRCgpO1xuXHQgICAgICAgIG1lbW9pemUoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB2YXIgc2NyaXB0O1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgc2NyaXB0ID0gZ2V0Q3VycmVudFNjcmlwdCgpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50VUlEO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciB1aWQgPSBzY3JpcHQuZ2V0QXR0cmlidXRlKFwiZGF0YS11aWRcIik7XG5cdCAgICAgICAgICAgIGlmICh1aWQgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgdWlkKSByZXR1cm4gdWlkO1xuXHQgICAgICAgICAgICBpZiAoKHVpZCA9IHNjcmlwdC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXVpZC1hdXRvXCIpKSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB1aWQpIHJldHVybiB1aWQ7XG5cdCAgICAgICAgICAgIGlmIChzY3JpcHQuc3JjKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgaGFzaGVkU3RyaW5nID0gZnVuY3Rpb24oc3RyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGhhc2ggPSBcIlwiO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IHN0cltpXS5jaGFyQ29kZUF0KDApICogaTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RyW2kgKyAxXSAmJiAodG90YWwgKz0gc3RyW2kgKyAxXS5jaGFyQ29kZUF0KDApICogKGkgLSAxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc2ggKz0gU3RyaW5nLmZyb21DaGFyQ29kZSg5NyArIE1hdGguYWJzKHRvdGFsKSAlIDI2KTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgICAgICAgICB9KEpTT04uc3RyaW5naWZ5KHtcblx0ICAgICAgICAgICAgICAgICAgICBzcmM6IHNjcmlwdC5zcmMsXG5cdCAgICAgICAgICAgICAgICAgICAgZGF0YXNldDogc2NyaXB0LmRhdGFzZXRcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHVpZCA9IFwidWlkX1wiICsgaGFzaGVkU3RyaW5nLnNsaWNlKGhhc2hlZFN0cmluZy5sZW5ndGggLSAzMCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB1aWQgPSB1bmlxdWVJRCgpO1xuXHQgICAgICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKFwiZGF0YS11aWQtYXV0b1wiLCB1aWQpO1xuXHQgICAgICAgICAgICByZXR1cm4gdWlkO1xuXHQgICAgICAgIH0pKTtcblx0ICAgICAgICBmdW5jdGlvbiBnbG9iYWxfZ2V0R2xvYmFsKHdpbikge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgdmFyIGdsb2JhbEtleSA9IFwiX19wb3N0X3JvYm90XzEwXzBfNDZfX1wiO1xuXHQgICAgICAgICAgICByZXR1cm4gd2luICE9PSB3aW5kb3cgPyB3aW5bZ2xvYmFsS2V5XSA6IHdpbltnbG9iYWxLZXldID0gd2luW2dsb2JhbEtleV0gfHwge307XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBnZXRPYmogPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZnVuY3Rpb24gZ2xvYmFsU3RvcmUoa2V5LCBkZWZTdG9yZSkge1xuXHQgICAgICAgICAgICB2b2lkIDAgPT09IGtleSAmJiAoa2V5ID0gXCJzdG9yZVwiKTtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBkZWZTdG9yZSAmJiAoZGVmU3RvcmUgPSBnZXRPYmopO1xuXHQgICAgICAgICAgICByZXR1cm4gdXRpbF9nZXRPclNldChnbG9iYWxfZ2V0R2xvYmFsKCksIGtleSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gZGVmU3RvcmUoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzOiBmdW5jdGlvbihzdG9yZUtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RvcmUuaGFzT3duUHJvcGVydHkoc3RvcmVLZXkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbihzdG9yZUtleSwgZGVmVmFsKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZS5oYXNPd25Qcm9wZXJ0eShzdG9yZUtleSkgPyBzdG9yZVtzdG9yZUtleV0gOiBkZWZWYWw7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHN0b3JlS2V5LCB2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmVbc3RvcmVLZXldID0gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZGVsOiBmdW5jdGlvbihzdG9yZUtleSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmVbc3RvcmVLZXldO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0T3JTZXQ6IGZ1bmN0aW9uKHN0b3JlS2V5LCBnZXR0ZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHV0aWxfZ2V0T3JTZXQoc3RvcmUsIHN0b3JlS2V5LCBnZXR0ZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdG9yZSA9IGRlZlN0b3JlKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBrZXlzOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0b3JlKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIHZhciBXaWxkQ2FyZCA9IGZ1bmN0aW9uKCkge307XG5cdCAgICAgICAgZnVuY3Rpb24gZ2V0V2lsZGNhcmQoKSB7XG5cdCAgICAgICAgICAgIHZhciBnbG9iYWwgPSBnbG9iYWxfZ2V0R2xvYmFsKCk7XG5cdCAgICAgICAgICAgIGdsb2JhbC5XSU5ET1dfV0lMRENBUkQgPSBnbG9iYWwuV0lORE9XX1dJTERDQVJEIHx8IG5ldyBXaWxkQ2FyZDtcblx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbC5XSU5ET1dfV0lMRENBUkQ7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHdpbmRvd1N0b3JlKGtleSwgZGVmU3RvcmUpIHtcblx0ICAgICAgICAgICAgdm9pZCAwID09PSBrZXkgJiYgKGtleSA9IFwic3RvcmVcIik7XG5cdCAgICAgICAgICAgIHZvaWQgMCA9PT0gZGVmU3RvcmUgJiYgKGRlZlN0b3JlID0gZ2V0T2JqKTtcblx0ICAgICAgICAgICAgcmV0dXJuIGdsb2JhbFN0b3JlKFwid2luZG93U3RvcmVcIikuZ2V0T3JTZXQoa2V5LCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luU3RvcmUgPSBuZXcgd2Vha21hcF9Dcm9zc0RvbWFpblNhZmVXZWFrTWFwO1xuXHQgICAgICAgICAgICAgICAgdmFyIGdldFN0b3JlID0gZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblN0b3JlLmdldE9yU2V0KHdpbiwgZGVmU3RvcmUpO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzOiBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldFN0b3JlKHdpbikuaGFzT3duUHJvcGVydHkoa2V5KTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24od2luLCBkZWZWYWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JlID0gZ2V0U3RvcmUod2luKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0b3JlLmhhc093blByb3BlcnR5KGtleSkgPyBzdG9yZVtrZXldIDogZGVmVmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih3aW4sIHZhbCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBnZXRTdG9yZSh3aW4pW2tleV0gPSB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgICAgICBkZWw6IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZ2V0U3RvcmUod2luKVtrZXldO1xuXHQgICAgICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICAgICAgZ2V0T3JTZXQ6IGZ1bmN0aW9uKHdpbiwgZ2V0dGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1dGlsX2dldE9yU2V0KGdldFN0b3JlKHdpbiksIGtleSwgZ2V0dGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEluc3RhbmNlSUQoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcImluc3RhbmNlXCIpLmdldE9yU2V0KFwiaW5zdGFuY2VJRFwiLCB1bmlxdWVJRCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlc29sdmVIZWxsb1Byb21pc2Uod2luLCBfcmVmKSB7XG5cdCAgICAgICAgICAgIHZhciBkb21haW4gPSBfcmVmLmRvbWFpbjtcblx0ICAgICAgICAgICAgdmFyIGhlbGxvUHJvbWlzZXMgPSB3aW5kb3dTdG9yZShcImhlbGxvUHJvbWlzZXNcIik7XG5cdCAgICAgICAgICAgIHZhciBleGlzdGluZ1Byb21pc2UgPSBoZWxsb1Byb21pc2VzLmdldCh3aW4pO1xuXHQgICAgICAgICAgICBleGlzdGluZ1Byb21pc2UgJiYgZXhpc3RpbmdQcm9taXNlLnJlc29sdmUoe1xuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHZhciBuZXdQcm9taXNlID0gcHJvbWlzZV9aYWxnb1Byb21pc2UucmVzb2x2ZSh7XG5cdCAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpblxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgaGVsbG9Qcm9taXNlcy5zZXQod2luLCBuZXdQcm9taXNlKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ld1Byb21pc2U7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNheUhlbGxvKHdpbiwgX3JlZjQpIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgwLCBfcmVmNC5zZW5kKSh3aW4sIFwicG9zdHJvYm90X2hlbGxvXCIsIHtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlSUQ6IGdldEluc3RhbmNlSUQoKVxuXHQgICAgICAgICAgICB9LCB7XG5cdCAgICAgICAgICAgICAgICBkb21haW46IFwiKlwiLFxuXHQgICAgICAgICAgICAgICAgdGltZW91dDogLTFcblx0ICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjUpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBvcmlnaW4gPSBfcmVmNS5vcmlnaW4sIGluc3RhbmNlSUQgPSBfcmVmNS5kYXRhLmluc3RhbmNlSUQ7XG5cdCAgICAgICAgICAgICAgICByZXNvbHZlSGVsbG9Qcm9taXNlKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogb3JpZ2luXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgd2luOiB3aW4sXG5cdCAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJRDogaW5zdGFuY2VJRFxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRXaW5kb3dJbnN0YW5jZUlEKHdpbiwgX3JlZjYpIHtcblx0ICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmNi5zZW5kO1xuXHQgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJ3aW5kb3dJbnN0YW5jZUlEUHJvbWlzZXNcIikuZ2V0T3JTZXQod2luLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc2F5SGVsbG8od2luLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjcpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZjcuaW5zdGFuY2VJRDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBtYXJrV2luZG93S25vd24od2luKSB7XG5cdCAgICAgICAgICAgIHdpbmRvd1N0b3JlKFwia25vd25XaW5kb3dzXCIpLnNldCh3aW4sIHRydWUpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBpc1NlcmlhbGl6ZWRUeXBlKGl0ZW0pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0XCIgPT0gdHlwZW9mIGl0ZW0gJiYgbnVsbCAhPT0gaXRlbSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBpdGVtLl9fdHlwZV9fO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBkZXRlcm1pbmVUeXBlKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdm9pZCAwID09PSB2YWwgPyBcInVuZGVmaW5lZFwiIDogbnVsbCA9PT0gdmFsID8gXCJudWxsXCIgOiBBcnJheS5pc0FycmF5KHZhbCkgPyBcImFycmF5XCIgOiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHZhbCA/IFwiZnVuY3Rpb25cIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIHZhbCA/IHZhbCBpbnN0YW5jZW9mIEVycm9yID8gXCJlcnJvclwiIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiB2YWwudGhlbiA/IFwicHJvbWlzZVwiIDogXCJbb2JqZWN0IFJlZ0V4cF1cIiA9PT0ge30udG9TdHJpbmcuY2FsbCh2YWwpID8gXCJyZWdleFwiIDogXCJbb2JqZWN0IERhdGVdXCIgPT09IHt9LnRvU3RyaW5nLmNhbGwodmFsKSA/IFwiZGF0ZVwiIDogXCJvYmplY3RcIiA6IFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCA/IFwic3RyaW5nXCIgOiBcIm51bWJlclwiID09IHR5cGVvZiB2YWwgPyBcIm51bWJlclwiIDogXCJib29sZWFuXCIgPT0gdHlwZW9mIHZhbCA/IFwiYm9vbGVhblwiIDogdm9pZCAwO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVUeXBlKHR5cGUsIHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgX190eXBlX186IHR5cGUsXG5cdCAgICAgICAgICAgICAgICBfX3ZhbF9fOiB2YWxcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIF9TRVJJQUxJWkVSO1xuXHQgICAgICAgIHZhciBTRVJJQUxJWkVSID0gKChfU0VSSUFMSVpFUiA9IHt9KS5mdW5jdGlvbiA9IGZ1bmN0aW9uKCkge30sIF9TRVJJQUxJWkVSLmVycm9yID0gZnVuY3Rpb24oX3JlZikge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImVycm9yXCIsIHtcblx0ICAgICAgICAgICAgICAgIG1lc3NhZ2U6IF9yZWYubWVzc2FnZSxcblx0ICAgICAgICAgICAgICAgIHN0YWNrOiBfcmVmLnN0YWNrLFxuXHQgICAgICAgICAgICAgICAgY29kZTogX3JlZi5jb2RlLFxuXHQgICAgICAgICAgICAgICAgZGF0YTogX3JlZi5kYXRhXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLnByb21pc2UgPSBmdW5jdGlvbigpIHt9LCBfU0VSSUFMSVpFUi5yZWdleCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcInJlZ2V4XCIsIHZhbC5zb3VyY2UpO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSLmRhdGUgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJkYXRlXCIsIHZhbC50b0pTT04oKSk7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIuYXJyYXkgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5zdHJpbmcgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5udW1iZXIgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUi5ib29sZWFuID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX1NFUklBTElaRVIubnVsbCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9TRVJJQUxJWkVSW3ZvaWQgMF0gPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZVR5cGUoXCJ1bmRlZmluZWRcIiwgdmFsKTtcblx0ICAgICAgICB9LCBfU0VSSUFMSVpFUik7XG5cdCAgICAgICAgdmFyIGRlZmF1bHRTZXJpYWxpemVycyA9IHt9O1xuXHQgICAgICAgIHZhciBfREVTRVJJQUxJWkVSO1xuXHQgICAgICAgIHZhciBERVNFUklBTElaRVIgPSAoKF9ERVNFUklBTElaRVIgPSB7fSkuZnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gc2VyaWFsaXphdGlvbiBpcyBub3QgaW1wbGVtZW50ZWQ7IG5vdGhpbmcgdG8gZGVzZXJpYWxpemVcIik7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5lcnJvciA9IGZ1bmN0aW9uKF9yZWYyKSB7XG5cdCAgICAgICAgICAgIHZhciBzdGFjayA9IF9yZWYyLnN0YWNrLCBjb2RlID0gX3JlZjIuY29kZSwgZGF0YSA9IF9yZWYyLmRhdGE7XG5cdCAgICAgICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcihfcmVmMi5tZXNzYWdlKTtcblx0ICAgICAgICAgICAgZXJyb3IuY29kZSA9IGNvZGU7XG5cdCAgICAgICAgICAgIGRhdGEgJiYgKGVycm9yLmRhdGEgPSBkYXRhKTtcblx0ICAgICAgICAgICAgZXJyb3Iuc3RhY2sgPSBzdGFjayArIFwiXFxuXFxuXCIgKyBlcnJvci5zdGFjaztcblx0ICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIucHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9taXNlIHNlcmlhbGl6YXRpb24gaXMgbm90IGltcGxlbWVudGVkOyBub3RoaW5nIHRvIGRlc2VyaWFsaXplXCIpO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIucmVnZXggPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodmFsKTtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLmRhdGUgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbCk7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5hcnJheSA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIub2JqZWN0ID0gZnVuY3Rpb24odmFsKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB2YWw7XG5cdCAgICAgICAgfSwgX0RFU0VSSUFMSVpFUi5zdHJpbmcgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHZhbDtcblx0ICAgICAgICB9LCBfREVTRVJJQUxJWkVSLm51bWJlciA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIuYm9vbGVhbiA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVIubnVsbCA9IGZ1bmN0aW9uKHZhbCkge1xuXHQgICAgICAgICAgICByZXR1cm4gdmFsO1xuXHQgICAgICAgIH0sIF9ERVNFUklBTElaRVJbdm9pZCAwXSA9IGZ1bmN0aW9uKCkge30sIF9ERVNFUklBTElaRVIpO1xuXHQgICAgICAgIHZhciBkZWZhdWx0RGVzZXJpYWxpemVycyA9IHt9O1xuXHQgICAgICAgIG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZSgoZnVuY3Rpb24ocmVzb2x2ZSkge1xuXHQgICAgICAgICAgICBpZiAod2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5ib2R5KSByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQuYm9keSk7XG5cdCAgICAgICAgICAgIHZhciBpbnRlcnZhbCA9IHNldEludGVydmFsKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmJvZHkpIHtcblx0ICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh3aW5kb3cuZG9jdW1lbnQuYm9keSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0pLCAxMCk7XG5cdCAgICAgICAgfSkpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGNsZWFudXBQcm94eVdpbmRvd3MoKSB7XG5cdCAgICAgICAgICAgIHZhciBpZFRvUHJveHlXaW5kb3cgPSBnbG9iYWxTdG9yZShcImlkVG9Qcm94eVdpbmRvd1wiKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2lkVG9Qcm94eVdpbmRvdyRrZXlzMiA9IGlkVG9Qcm94eVdpbmRvdy5rZXlzKCk7IF9pMiA8IF9pZFRvUHJveHlXaW5kb3cka2V5czIubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGlkID0gX2lkVG9Qcm94eVdpbmRvdyRrZXlzMltfaTJdO1xuXHQgICAgICAgICAgICAgICAgaWRUb1Byb3h5V2luZG93LmdldChpZCkuc2hvdWxkQ2xlYW4oKSAmJiBpZFRvUHJveHlXaW5kb3cuZGVsKGlkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBnZXRTZXJpYWxpemVkV2luZG93KHdpblByb21pc2UsIF9yZWYpIHtcblx0ICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmLnNlbmQsIF9yZWYkaWQgPSBfcmVmLmlkLCBpZCA9IHZvaWQgMCA9PT0gX3JlZiRpZCA/IHVuaXF1ZUlEKCkgOiBfcmVmJGlkO1xuXHQgICAgICAgICAgICB2YXIgd2luZG93TmFtZVByb21pc2UgPSB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgaWYgKGlzU2FtZURvbWFpbih3aW4pKSByZXR1cm4gYXNzZXJ0U2FtZURvbWFpbih3aW4pLm5hbWU7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgdmFyIHdpbmRvd1R5cGVQcm9taXNlID0gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW5kb3cpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW5kb3cpKSB0aHJvdyBuZXcgRXJyb3IoXCJXaW5kb3cgaXMgY2xvc2VkLCBjYW4gbm90IGRldGVybWluZSB0eXBlXCIpO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGdldE9wZW5lcih3aW5kb3cpID8gXCJwb3B1cFwiIDogXCJpZnJhbWVcIjtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB3aW5kb3dOYW1lUHJvbWlzZS5jYXRjaChzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICAgICAgd2luZG93VHlwZVByb21pc2UuY2F0Y2goc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgICAgIHZhciBnZXROYW1lID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWlzV2luZG93Q2xvc2VkKHdpbikpIHJldHVybiBpc1NhbWVEb21haW4od2luKSA/IGFzc2VydFNhbWVEb21haW4od2luKS5uYW1lIDogd2luZG93TmFtZVByb21pc2U7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICBnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93VHlwZVByb21pc2U7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgZ2V0SW5zdGFuY2VJRDogbWVtb2l6ZVByb21pc2UoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0V2luZG93SW5zdGFuY2VJRCh3aW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpLFxuXHQgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oY2xvc2VXaW5kb3cpO1xuXHQgICAgICAgICAgICAgICAgfSxcblx0ICAgICAgICAgICAgICAgIGdldE5hbWU6IGdldE5hbWUsXG5cdCAgICAgICAgICAgICAgICBmb2N1czogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5mb2N1cygpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpblByb21pc2UudGhlbigoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1dpbmRvd0Nsb3NlZCh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0sXG5cdCAgICAgICAgICAgICAgICBzZXRMb2NhdGlvbjogZnVuY3Rpb24oaHJlZiwgb3B0cykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gb3B0cyAmJiAob3B0cyA9IHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luUHJvbWlzZS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbiA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiArIHdpbmRvdy5sb2NhdGlvbi5ob3N0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX29wdHMkbWV0aG9kID0gb3B0cy5tZXRob2QsIG1ldGhvZCA9IHZvaWQgMCA9PT0gX29wdHMkbWV0aG9kID8gXCJnZXRcIiA6IF9vcHRzJG1ldGhvZCwgYm9keSA9IG9wdHMuYm9keTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKDAgPT09IGhyZWYuaW5kZXhPZihcIi9cIikpIGhyZWYgPSBcIlwiICsgZG9tYWluICsgaHJlZjsgZWxzZSBpZiAoIWhyZWYubWF0Y2goL15odHRwcz86XFwvXFwvLykgJiYgMCAhPT0gaHJlZi5pbmRleE9mKGRvbWFpbikpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIHVybCB0byBiZSBodHRwIG9yIGh0dHBzIHVybCwgb3IgYWJzb2x1dGUgcGF0aCwgZ290IFwiICsgSlNPTi5zdHJpbmdpZnkoaHJlZikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJwb3N0XCIgPT09IG1ldGhvZCkgcmV0dXJuIGdldE5hbWUoKS50aGVuKChmdW5jdGlvbihuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgcG9zdCB0byB3aW5kb3cgd2l0aG91dCB0YXJnZXQgbmFtZVwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihfcmVmMykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBfcmVmMy51cmwsIHRhcmdldCA9IF9yZWYzLnRhcmdldCwgYm9keSA9IF9yZWYzLmJvZHksIF9yZWYzJG1ldGhvZCA9IF9yZWYzLm1ldGhvZCwgbWV0aG9kID0gdm9pZCAwID09PSBfcmVmMyRtZXRob2QgPyBcInBvc3RcIiA6IF9yZWYzJG1ldGhvZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc2V0QXR0cmlidXRlKFwidGFyZ2V0XCIsIHRhcmdldCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zZXRBdHRyaWJ1dGUoXCJtZXRob2RcIiwgbWV0aG9kKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtLnNldEF0dHJpYnV0ZShcImFjdGlvblwiLCB1cmwpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5KSBmb3IgKHZhciBfaTI0ID0gMCwgX09iamVjdCRrZXlzNCA9IE9iamVjdC5rZXlzKGJvZHkpOyBfaTI0IDwgX09iamVjdCRrZXlzNC5sZW5ndGg7IF9pMjQrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2JvZHkka2V5O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX09iamVjdCRrZXlzNFtfaTI0XTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoXCJuYW1lXCIsIGtleSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIG51bGwgPT0gKF9ib2R5JGtleSA9IGJvZHlba2V5XSkgPyB2b2lkIDAgOiBfYm9keSRrZXkudG9TdHJpbmcoKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCb2R5KCkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5zdWJtaXQoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRCb2R5KCkucmVtb3ZlQ2hpbGQoZm9ybSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGhyZWYsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGJvZHlcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImdldFwiICE9PSBtZXRob2QpIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIG1ldGhvZDogXCIgKyBtZXRob2QpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNTYW1lRG9tYWluKHdpbikpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luLmxvY2F0aW9uICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygd2luLmxvY2F0aW9uLnJlcGxhY2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW4ubG9jYXRpb24ucmVwbGFjZShocmVmKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luLmxvY2F0aW9uID0gaHJlZjtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9LFxuXHQgICAgICAgICAgICAgICAgc2V0TmFtZTogZnVuY3Rpb24obmFtZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5Qcm9taXNlLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2FtZURvbWFpbiA9IGlzU2FtZURvbWFpbih3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBnZXRGcmFtZUZvcldpbmRvdyh3aW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNhbWVEb21haW4pIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3Qgc2V0IG5hbWUgZm9yIGNyb3NzLWRvbWFpbiB3aW5kb3c6IFwiICsgbmFtZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFNhbWVEb21haW4od2luKS5uYW1lID0gbmFtZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnJhbWUgJiYgZnJhbWUuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBuYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93TmFtZVByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5yZXNvbHZlKG5hbWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHdpbmRvd19Qcm94eVdpbmRvdyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBQcm94eVdpbmRvdyhfcmVmMikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHNlbmQgPSBfcmVmMi5zZW5kLCB3aW4gPSBfcmVmMi53aW4sIHNlcmlhbGl6ZWRXaW5kb3cgPSBfcmVmMi5zZXJpYWxpemVkV2luZG93O1xuXHQgICAgICAgICAgICAgICAgdGhpcy5pZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuaXNQcm94eVdpbmRvdyA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cgPSB2b2lkIDA7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvdyA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VuZCA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZSA9IG5ldyBwcm9taXNlX1phbGdvUHJvbWlzZTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZFdpbmRvdyA9IHNlcmlhbGl6ZWRXaW5kb3cgfHwgZ2V0U2VyaWFsaXplZFdpbmRvdyh0aGlzLmFjdHVhbFdpbmRvd1Byb21pc2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIGdsb2JhbFN0b3JlKFwiaWRUb1Byb3h5V2luZG93XCIpLnNldCh0aGlzLmdldElEKCksIHRoaXMpO1xuXHQgICAgICAgICAgICAgICAgd2luICYmIHRoaXMuc2V0V2luZG93KHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBfcHJvdG8gPSBQcm94eVdpbmRvdy5wcm90b3R5cGU7XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRJRCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5pZDtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmdldFR5cGUgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuZ2V0VHlwZSgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uaXNQb3B1cCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnRoZW4oKGZ1bmN0aW9uKHR5cGUpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJwb3B1cFwiID09PSB0eXBlO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2V0TG9jYXRpb24gPSBmdW5jdGlvbihocmVmLCBvcHRzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5zZXRMb2NhdGlvbihocmVmLCBvcHRzKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXROYW1lID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldE5hbWUoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNldE5hbWUgPSBmdW5jdGlvbihuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZWRXaW5kb3cuc2V0TmFtZShuYW1lKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5jbG9zZSgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczM7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5mb2N1cyA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cdCAgICAgICAgICAgICAgICB2YXIgaXNQb3B1cFByb21pc2UgPSB0aGlzLmlzUG9wdXAoKTtcblx0ICAgICAgICAgICAgICAgIHZhciBnZXROYW1lUHJvbWlzZSA9IHRoaXMuZ2V0TmFtZSgpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHJlb3BlblByb21pc2UgPSBwcm9taXNlX1phbGdvUHJvbWlzZS5oYXNoKHtcblx0ICAgICAgICAgICAgICAgICAgICBpc1BvcHVwOiBpc1BvcHVwUHJvbWlzZSxcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBnZXROYW1lUHJvbWlzZVxuXHQgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjMpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgX3JlZjMuaXNQb3B1cCAmJiBuYW1lICYmIHdpbmRvdy5vcGVuKFwiXCIsIG5hbWUsIFwibm9vcGVuZXJcIik7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgZm9jdXNQcm9taXNlID0gdGhpcy5zZXJpYWxpemVkV2luZG93LmZvY3VzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZV9aYWxnb1Byb21pc2UuYWxsKFsgcmVvcGVuUHJvbWlzZSwgZm9jdXNQcm9taXNlIF0pLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczQ7XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5pc0Nsb3NlZCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplZFdpbmRvdy5pc0Nsb3NlZCgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uZ2V0V2luZG93ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3R1YWxXaW5kb3c7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5zZXRXaW5kb3cgPSBmdW5jdGlvbih3aW4sIF9yZWY0KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY0LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICB0aGlzLmFjdHVhbFdpbmRvdyA9IHdpbjtcblx0ICAgICAgICAgICAgICAgIHRoaXMuYWN0dWFsV2luZG93UHJvbWlzZS5yZXNvbHZlKHRoaXMuYWN0dWFsV2luZG93KTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2VyaWFsaXplZFdpbmRvdyA9IGdldFNlcmlhbGl6ZWRXaW5kb3codGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZCxcblx0ICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5nZXRJRCgpXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIHdpbmRvd1N0b3JlKFwid2luVG9Qcm94eVdpbmRvd1wiKS5zZXQod2luLCB0aGlzKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLmF3YWl0V2luZG93ID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hY3R1YWxXaW5kb3dQcm9taXNlO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8ubWF0Y2hXaW5kb3cgPSBmdW5jdGlvbih3aW4sIF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgX3RoaXM1ID0gdGhpcztcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjUuc2VuZDtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczUuYWN0dWFsV2luZG93ID8gd2luID09PSBfdGhpczUuYWN0dWFsV2luZG93IDogcHJvbWlzZV9aYWxnb1Byb21pc2UuaGFzaCh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5SW5zdGFuY2VJRDogX3RoaXM1LmdldEluc3RhbmNlSUQoKSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAga25vd25XaW5kb3dJbnN0YW5jZUlEOiBnZXRXaW5kb3dJbnN0YW5jZUlEKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KVxuXHQgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKF9yZWY2KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IF9yZWY2LnByb3h5SW5zdGFuY2VJRCA9PT0gX3JlZjYua25vd25XaW5kb3dJbnN0YW5jZUlEO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCAmJiBfdGhpczUuc2V0V2luZG93KHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnVud3JhcCA9IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0dWFsV2luZG93IHx8IHRoaXM7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIF9wcm90by5nZXRJbnN0YW5jZUlEID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93LmdldEluc3RhbmNlSUQoKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgX3Byb3RvLnNob3VsZENsZWFuID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmFjdHVhbFdpbmRvdyAmJiBpc1dpbmRvd0Nsb3NlZCh0aGlzLmFjdHVhbFdpbmRvdykpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBfcHJvdG8uc2VyaWFsaXplID0gZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVkV2luZG93O1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy51bndyYXAgPSBmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHdpbikgPyB3aW4udW53cmFwKCkgOiB3aW47XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIFByb3h5V2luZG93LnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHdpbiwgX3JlZjcpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjcuc2VuZDtcblx0ICAgICAgICAgICAgICAgIGNsZWFudXBQcm94eVdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBQcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pLnNlcmlhbGl6ZSgpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICBQcm94eVdpbmRvdy5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRXaW5kb3csIF9yZWY4KSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWY4LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICBjbGVhbnVwUHJveHlXaW5kb3dzKCk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJpZFRvUHJveHlXaW5kb3dcIikuZ2V0KHNlcmlhbGl6ZWRXaW5kb3cuaWQpIHx8IG5ldyBQcm94eVdpbmRvdyh7XG5cdCAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZFdpbmRvdzogc2VyaWFsaXplZFdpbmRvdyxcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyA9IGZ1bmN0aW9uKG9iaikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4ob2JqICYmICFpc1dpbmRvdyhvYmopICYmIG9iai5pc1Byb3h5V2luZG93KTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyA9IGZ1bmN0aW9uKHdpbiwgX3JlZjkpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjkuc2VuZDtcblx0ICAgICAgICAgICAgICAgIGNsZWFudXBQcm94eVdpbmRvd3MoKTtcblx0ICAgICAgICAgICAgICAgIGlmIChQcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHdpbikpIHJldHVybiB3aW47XG5cdCAgICAgICAgICAgICAgICB2YXIgYWN0dWFsV2luZG93ID0gd2luO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwid2luVG9Qcm94eVdpbmRvd1wiKS5nZXQoYWN0dWFsV2luZG93KSB8fCBuZXcgUHJveHlXaW5kb3coe1xuXHQgICAgICAgICAgICAgICAgICAgIHdpbjogYWN0dWFsV2luZG93LFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICByZXR1cm4gUHJveHlXaW5kb3c7XG5cdCAgICAgICAgfSgpO1xuXHQgICAgICAgIGZ1bmN0aW9uIGFkZE1ldGhvZChpZCwgdmFsLCBuYW1lLCBzb3VyY2UsIGRvbWFpbikge1xuXHQgICAgICAgICAgICB2YXIgbWV0aG9kU3RvcmUgPSB3aW5kb3dTdG9yZShcIm1ldGhvZFN0b3JlXCIpO1xuXHQgICAgICAgICAgICB2YXIgcHJveHlXaW5kb3dNZXRob2RzID0gZ2xvYmFsU3RvcmUoXCJwcm94eVdpbmRvd01ldGhvZHNcIik7XG5cdCAgICAgICAgICAgIGlmICh3aW5kb3dfUHJveHlXaW5kb3cuaXNQcm94eVdpbmRvdyhzb3VyY2UpKSBwcm94eVdpbmRvd01ldGhvZHMuc2V0KGlkLCB7XG5cdCAgICAgICAgICAgICAgICB2YWw6IHZhbCxcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG5cdCAgICAgICAgICAgIH0pOyBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHByb3h5V2luZG93TWV0aG9kcy5kZWwoaWQpO1xuXHQgICAgICAgICAgICAgICAgbWV0aG9kU3RvcmUuZ2V0T3JTZXQoc291cmNlLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICAgICAgfSkpW2lkXSA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgIHZhbDogdmFsLFxuXHQgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlXG5cdCAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGxvb2t1cE1ldGhvZChzb3VyY2UsIGlkKSB7XG5cdCAgICAgICAgICAgIHZhciBtZXRob2RTdG9yZSA9IHdpbmRvd1N0b3JlKFwibWV0aG9kU3RvcmVcIik7XG5cdCAgICAgICAgICAgIHZhciBwcm94eVdpbmRvd01ldGhvZHMgPSBnbG9iYWxTdG9yZShcInByb3h5V2luZG93TWV0aG9kc1wiKTtcblx0ICAgICAgICAgICAgcmV0dXJuIG1ldGhvZFN0b3JlLmdldE9yU2V0KHNvdXJjZSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuXHQgICAgICAgICAgICB9KSlbaWRdIHx8IHByb3h5V2luZG93TWV0aG9kcy5nZXQoaWQpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBmdW5jdGlvbl9zZXJpYWxpemVGdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCB2YWwsIGtleSwgX3JlZjMpIHtcblx0ICAgICAgICAgICAgb24gPSAoX3JlZiA9IHtcblx0ICAgICAgICAgICAgICAgIG9uOiBfcmVmMy5vbixcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IF9yZWYzLnNlbmRcblx0ICAgICAgICAgICAgfSkub24sIHNlbmQgPSBfcmVmLnNlbmQsIGdsb2JhbFN0b3JlKFwiYnVpbHRpbkxpc3RlbmVyc1wiKS5nZXRPclNldChcImZ1bmN0aW9uQ2FsbHNcIiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG9uKFwicG9zdHJvYm90X21ldGhvZFwiLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBcIipcIlxuXHQgICAgICAgICAgICAgICAgfSwgKGZ1bmN0aW9uKF9yZWYyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IF9yZWYyLnNvdXJjZSwgb3JpZ2luID0gX3JlZjIub3JpZ2luLCBkYXRhID0gX3JlZjIuZGF0YTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBkYXRhLmlkLCBuYW1lID0gZGF0YS5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXRoID0gbG9va3VwTWV0aG9kKHNvdXJjZSwgaWQpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbWV0aCkgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgbWV0aG9kICdcIiArIG5hbWUgKyBcIicgd2l0aCBpZDogXCIgKyBkYXRhLmlkICsgXCIgaW4gXCIgKyBnZXREb21haW4od2luZG93KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG1ldGhvZFNvdXJjZSA9IG1ldGguc291cmNlLCBkb21haW4gPSBtZXRoLmRvbWFpbiwgdmFsID0gbWV0aC52YWw7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4oZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2QgJ1wiICsgZGF0YS5uYW1lICsgXCInIGRvbWFpbiBcIiArIEpTT04uc3RyaW5naWZ5KHV0aWxfaXNSZWdleChtZXRoLmRvbWFpbikgPyBtZXRoLmRvbWFpbi5zb3VyY2UgOiBtZXRoLmRvbWFpbikgKyBcIiBkb2VzIG5vdCBtYXRjaCBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBpbiBcIiArIGdldERvbWFpbih3aW5kb3cpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KG1ldGhvZFNvdXJjZSkpIHJldHVybiBtZXRob2RTb3VyY2UubWF0Y2hXaW5kb3coc291cmNlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLnRoZW4oKGZ1bmN0aW9uKG1hdGNoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKSB0aHJvdyBuZXcgRXJyb3IoXCJNZXRob2QgY2FsbCAnXCIgKyBkYXRhLm5hbWUgKyBcIicgZmFpbGVkIC0gcHJveHkgd2luZG93IGRvZXMgbm90IG1hdGNoIHNvdXJjZSBpbiBcIiArIGdldERvbWFpbih3aW5kb3cpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC5hcHBseSh7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIGRhdGEuYXJncyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsLm9uRXJyb3IpIHJldHVybiB2YWwub25FcnJvcihlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuc3RhY2sgJiYgKGVyci5zdGFjayA9IFwiUmVtb3RlIGNhbGwgdG8gXCIgKyBuYW1lICsgXCIoXCIgKyBmdW5jdGlvbihhcmdzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdm9pZCAwID09PSBhcmdzICYmIChhcmdzID0gW10pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoaXRlbSA9IGFyZ3MsIFtdLnNsaWNlLmNhbGwoaXRlbSkpLm1hcCgoZnVuY3Rpb24oYXJnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBhcmcgPyBcIidcIiArIGFyZyArIFwiJ1wiIDogdm9pZCAwID09PSBhcmcgPyBcInVuZGVmaW5lZFwiIDogbnVsbCA9PT0gYXJnID8gXCJudWxsXCIgOiBcImJvb2xlYW5cIiA9PSB0eXBlb2YgYXJnID8gYXJnLnRvU3RyaW5nKCkgOiBBcnJheS5pc0FycmF5KGFyZykgPyBcIlsgLi4uIF1cIiA6IFwib2JqZWN0XCIgPT0gdHlwZW9mIGFyZyA/IFwieyAuLi4gfVwiIDogXCJmdW5jdGlvblwiID09IHR5cGVvZiBhcmcgPyBcIigpID0+IHsgLi4uIH1cIiA6IFwiPFwiICsgdHlwZW9mIGFyZyArIFwiPlwiO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5qb2luKFwiLCBcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGl0ZW07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGRhdGEuYXJncykgKyBcIikgZmFpbGVkXFxuXFxuXCIgKyBlcnIuc3RhY2spO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpLnRoZW4oKGZ1bmN0aW9uKHJlc3VsdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiByZXN1bHQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgIHZhciBfcmVmLCBvbiwgc2VuZDtcblx0ICAgICAgICAgICAgdmFyIGlkID0gdmFsLl9faWRfXyB8fCB1bmlxdWVJRCgpO1xuXHQgICAgICAgICAgICBkZXN0aW5hdGlvbiA9IHdpbmRvd19Qcm94eVdpbmRvdy51bndyYXAoZGVzdGluYXRpb24pO1xuXHQgICAgICAgICAgICB2YXIgbmFtZSA9IHZhbC5fX25hbWVfXyB8fCB2YWwubmFtZSB8fCBrZXk7XG5cdCAgICAgICAgICAgIFwic3RyaW5nXCIgPT0gdHlwZW9mIG5hbWUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBuYW1lLmluZGV4T2YgJiYgMCA9PT0gbmFtZS5pbmRleE9mKFwiYW5vbnltb3VzOjpcIikgJiYgKG5hbWUgPSBuYW1lLnJlcGxhY2UoXCJhbm9ueW1vdXM6OlwiLCBrZXkgKyBcIjo6XCIpKTtcblx0ICAgICAgICAgICAgaWYgKHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KGRlc3RpbmF0aW9uKSkge1xuXHQgICAgICAgICAgICAgICAgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIGRlc3RpbmF0aW9uLCBkb21haW4pO1xuXHQgICAgICAgICAgICAgICAgZGVzdGluYXRpb24uYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICBhZGRNZXRob2QoaWQsIHZhbCwgbmFtZSwgd2luLCBkb21haW4pO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9IGVsc2UgYWRkTWV0aG9kKGlkLCB2YWwsIG5hbWUsIGRlc3RpbmF0aW9uLCBkb21haW4pO1xuXHQgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImNyb3NzX2RvbWFpbl9mdW5jdGlvblwiLCB7XG5cdCAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICBuYW1lOiBuYW1lXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVNZXNzYWdlKGRlc3RpbmF0aW9uLCBkb21haW4sIG9iaiwgX3JlZikge1xuXHQgICAgICAgICAgICB2YXIgX3NlcmlhbGl6ZTtcblx0ICAgICAgICAgICAgdmFyIG9uID0gX3JlZi5vbiwgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgc2VyaWFsaXplcnMpIHtcblx0ICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gc2VyaWFsaXplcnMgJiYgKHNlcmlhbGl6ZXJzID0gZGVmYXVsdFNlcmlhbGl6ZXJzKTtcblx0ICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBKU09OLnN0cmluZ2lmeShvYmosIChmdW5jdGlvbihrZXkpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gdGhpc1trZXldO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1NlcmlhbGl6ZWRUeXBlKHRoaXMpKSByZXR1cm4gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZGV0ZXJtaW5lVHlwZSh2YWwpO1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghdHlwZSkgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgc2VyaWFsaXplciA9IHNlcmlhbGl6ZXJzW3R5cGVdIHx8IFNFUklBTElaRVJbdHlwZV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZXIgPyBzZXJpYWxpemVyKHZhbCwga2V5KSA6IHZhbDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIDAgPT09IHJlc3VsdCA/IFwidW5kZWZpbmVkXCIgOiByZXN1bHQ7XG5cdCAgICAgICAgICAgIH0ob2JqLCAoKF9zZXJpYWxpemUgPSB7fSkucHJvbWlzZSA9IGZ1bmN0aW9uKHZhbCwga2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgdmFsLCBrZXksIF9yZWYpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplVHlwZShcImNyb3NzX2RvbWFpbl96YWxnb19wcm9taXNlXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhlbjogZnVuY3Rpb25fc2VyaWFsaXplRnVuY3Rpb24oZGVzdGluYXRpb24sIGRvbWFpbiwgKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbC50aGVuKHJlc29sdmUsIHJlamVjdCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBrZXksIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBfcmVmLm9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogX3JlZi5zZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICB9KGRlc3RpbmF0aW9uLCBkb21haW4sIHZhbCwga2V5LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LCBfc2VyaWFsaXplLmZ1bmN0aW9uID0gZnVuY3Rpb24odmFsLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbl9zZXJpYWxpemVGdW5jdGlvbihkZXN0aW5hdGlvbiwgZG9tYWluLCB2YWwsIGtleSwge1xuXHQgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZS5vYmplY3QgPSBmdW5jdGlvbih2YWwpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBpc1dpbmRvdyh2YWwpIHx8IHdpbmRvd19Qcm94eVdpbmRvdy5pc1Byb3h5V2luZG93KHZhbCkgPyBzZXJpYWxpemVUeXBlKFwiY3Jvc3NfZG9tYWluX3dpbmRvd1wiLCB3aW5kb3dfUHJveHlXaW5kb3cuc2VyaWFsaXplKHZhbCwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pKSA6IHZhbDtcblx0ICAgICAgICAgICAgfSwgX3NlcmlhbGl6ZSkpO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBkZXNlcmlhbGl6ZU1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIF9yZWYyKSB7XG5cdCAgICAgICAgICAgIHZhciBfZGVzZXJpYWxpemU7XG5cdCAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjIuc2VuZDtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0ciwgZGVzZXJpYWxpemVycykge1xuXHQgICAgICAgICAgICAgICAgdm9pZCAwID09PSBkZXNlcmlhbGl6ZXJzICYmIChkZXNlcmlhbGl6ZXJzID0gZGVmYXVsdERlc2VyaWFsaXplcnMpO1xuXHQgICAgICAgICAgICAgICAgaWYgKFwidW5kZWZpbmVkXCIgIT09IHN0cikgcmV0dXJuIEpTT04ucGFyc2Uoc3RyLCAoZnVuY3Rpb24oa2V5LCB2YWwpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNTZXJpYWxpemVkVHlwZSh0aGlzKSkgcmV0dXJuIHZhbDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWU7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGlzU2VyaWFsaXplZFR5cGUodmFsKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gdmFsLl9fdHlwZV9fO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbC5fX3ZhbF9fO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBkZXRlcm1pbmVUeXBlKHZhbCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIXR5cGUpIHJldHVybiB2YWx1ZTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZGVzZXJpYWxpemVyID0gZGVzZXJpYWxpemVyc1t0eXBlXSB8fCBERVNFUklBTElaRVJbdHlwZV07XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplciA/IGRlc2VyaWFsaXplcih2YWx1ZSwga2V5KSA6IHZhbHVlO1xuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9KG1lc3NhZ2UsICgoX2Rlc2VyaWFsaXplID0ge30pLmNyb3NzX2RvbWFpbl96YWxnb19wcm9taXNlID0gZnVuY3Rpb24oc2VyaWFsaXplZFByb21pc2UpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UsIG9yaWdpbiwgX3JlZjIpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlKF9yZWYyLnRoZW4pO1xuXHQgICAgICAgICAgICAgICAgfSgwLCAwLCBzZXJpYWxpemVkUHJvbWlzZSk7XG5cdCAgICAgICAgICAgIH0sIF9kZXNlcmlhbGl6ZS5jcm9zc19kb21haW5fZnVuY3Rpb24gPSBmdW5jdGlvbihzZXJpYWxpemVkRnVuY3Rpb24pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihzb3VyY2UsIG9yaWdpbiwgX3JlZjQsIF9yZWY1KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gX3JlZjQuaWQsIG5hbWUgPSBfcmVmNC5uYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZW5kID0gX3JlZjUuc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2V0RGVzZXJpYWxpemVkRnVuY3Rpb24gPSBmdW5jdGlvbihvcHRzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gb3B0cyAmJiAob3B0cyA9IHt9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIoKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2FyZ3VtZW50cyA9IGFyZ3VtZW50cztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3cudG9Qcm94eVdpbmRvdyhzb3VyY2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5hd2FpdFdpbmRvdygpLnRoZW4oKGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXRoID0gbG9va3VwTWV0aG9kKHdpbiwgaWQpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXRoICYmIG1ldGgudmFsICE9PSBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcikgcmV0dXJuIG1ldGgudmFsLmFwcGx5KHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB3aW5kb3csXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKClcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBfYXJndW1lbnRzKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2FyZ3MgPSBbXS5zbGljZS5jYWxsKF9hcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRzLmZpcmVBbmRGb3JnZXQgPyBzZW5kKHdpbiwgXCJwb3N0cm9ib3RfbWV0aG9kXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBfYXJnc1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcmVBbmRGb3JnZXQ6IHRydWVcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSA6IHNlbmQod2luLCBcInBvc3Ryb2JvdF9tZXRob2RcIiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IF9hcmdzXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogZmFsc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbihyZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5kYXRhLnJlc3VsdDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkuY2F0Y2goKGZ1bmN0aW9uKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5fX25hbWVfXyA9IG5hbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLl9fb3JpZ2luX18gPSBvcmlnaW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLl9fc291cmNlX18gPSBzb3VyY2U7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNyb3NzRG9tYWluRnVuY3Rpb25XcmFwcGVyLl9faWRfXyA9IGlkO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlci5vcmlnaW4gPSBvcmlnaW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcjtcblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlciA9IGdldERlc2VyaWFsaXplZEZ1bmN0aW9uKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgY3Jvc3NEb21haW5GdW5jdGlvbldyYXBwZXIuZmlyZUFuZEZvcmdldCA9IGdldERlc2VyaWFsaXplZEZ1bmN0aW9uKHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgZmlyZUFuZEZvcmdldDogdHJ1ZVxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcm9zc0RvbWFpbkZ1bmN0aW9uV3JhcHBlcjtcblx0ICAgICAgICAgICAgICAgIH0oc291cmNlLCBvcmlnaW4sIHNlcmlhbGl6ZWRGdW5jdGlvbiwge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LCBfZGVzZXJpYWxpemUuY3Jvc3NfZG9tYWluX3dpbmRvdyA9IGZ1bmN0aW9uKHNlcmlhbGl6ZWRXaW5kb3cpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3dfUHJveHlXaW5kb3cuZGVzZXJpYWxpemUoc2VyaWFsaXplZFdpbmRvdywge1xuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9LCBfZGVzZXJpYWxpemUpKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIFNFTkRfTUVTU0FHRV9TVFJBVEVHSUVTID0ge307XG5cdCAgICAgICAgU0VORF9NRVNTQUdFX1NUUkFURUdJRVMucG9zdHJvYm90X3Bvc3RfbWVzc2FnZSA9IGZ1bmN0aW9uKHdpbiwgc2VyaWFsaXplZE1lc3NhZ2UsIGRvbWFpbikge1xuXHQgICAgICAgICAgICAwID09PSBkb21haW4uaW5kZXhPZihcImZpbGU6XCIpICYmIChkb21haW4gPSBcIipcIik7XG5cdCAgICAgICAgICAgIHdpbi5wb3N0TWVzc2FnZShzZXJpYWxpemVkTWVzc2FnZSwgZG9tYWluKTtcblx0ICAgICAgICB9O1xuXHQgICAgICAgIGZ1bmN0aW9uIHNlbmRfc2VuZE1lc3NhZ2Uod2luLCBkb21haW4sIG1lc3NhZ2UsIF9yZWYyKSB7XG5cdCAgICAgICAgICAgIHZhciBvbiA9IF9yZWYyLm9uLCBzZW5kID0gX3JlZjIuc2VuZDtcblx0ICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgZG9tYWluQnVmZmVyID0gd2luZG93U3RvcmUoKS5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICBkb21haW5CdWZmZXIuYnVmZmVyID0gZG9tYWluQnVmZmVyLmJ1ZmZlciB8fCBbXTtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbkJ1ZmZlci5idWZmZXIucHVzaChtZXNzYWdlKTtcblx0ICAgICAgICAgICAgICAgIGRvbWFpbkJ1ZmZlci5mbHVzaCA9IGRvbWFpbkJ1ZmZlci5mbHVzaCB8fCBwcm9taXNlX1phbGdvUHJvbWlzZS5mbHVzaCgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmIChpc1dpbmRvd0Nsb3NlZCh3aW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJXaW5kb3cgaXMgY2xvc2VkXCIpO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBzZXJpYWxpemVkTWVzc2FnZSA9IHNlcmlhbGl6ZU1lc3NhZ2Uod2luLCBkb21haW4sICgoX3JlZiA9IHt9KS5fX3Bvc3Rfcm9ib3RfMTBfMF80Nl9fID0gZG9tYWluQnVmZmVyLmJ1ZmZlciB8fCBbXSwgXG5cdCAgICAgICAgICAgICAgICAgICAgX3JlZiksIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIF9yZWY7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbkJ1ZmZlci5idWZmZXI7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHN0cmF0ZWdpZXMgPSBPYmplY3Qua2V5cyhTRU5EX01FU1NBR0VfU1RSQVRFR0lFUyk7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGVycm9ycyA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IHN0cmF0ZWdpZXMubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RyYXRlZ3lOYW1lID0gc3RyYXRlZ2llc1tfaTJdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgU0VORF9NRVNTQUdFX1NUUkFURUdJRVNbc3RyYXRlZ3lOYW1lXSh3aW4sIHNlcmlhbGl6ZWRNZXNzYWdlLCBkb21haW4pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGVycik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggPT09IHN0cmF0ZWdpZXMubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoXCJBbGwgcG9zdC1yb2JvdCBtZXNzYWdpbmcgc3RyYXRlZ2llcyBmYWlsZWQ6XFxuXFxuXCIgKyBlcnJvcnMubWFwKChmdW5jdGlvbihlcnIsIGkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKyBcIi4gXCIgKyBzdHJpbmdpZnlFcnJvcihlcnIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKS5qb2luKFwiXFxuXFxuXCIpKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkb21haW5CdWZmZXIuZmx1c2gudGhlbigoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGRvbWFpbkJ1ZmZlci5mbHVzaDtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSkpLnRoZW4oc3JjX3V0aWxfbm9vcCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFJlc3BvbnNlTGlzdGVuZXIoaGFzaCkge1xuXHQgICAgICAgICAgICByZXR1cm4gZ2xvYmFsU3RvcmUoXCJyZXNwb25zZUxpc3RlbmVyc1wiKS5nZXQoaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGRlbGV0ZVJlc3BvbnNlTGlzdGVuZXIoaGFzaCkge1xuXHQgICAgICAgICAgICBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpLmRlbChoYXNoKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaXNSZXNwb25zZUxpc3RlbmVyRXJyb3JlZChoYXNoKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBnbG9iYWxTdG9yZShcImVycm9yZWRSZXNwb25zZUxpc3RlbmVyc1wiKS5oYXMoaGFzaCk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGdldFJlcXVlc3RMaXN0ZW5lcihfcmVmKSB7XG5cdCAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLCB3aW4gPSBfcmVmLndpbiwgZG9tYWluID0gX3JlZi5kb21haW47XG5cdCAgICAgICAgICAgIHZhciByZXF1ZXN0TGlzdGVuZXJzID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0TGlzdGVuZXJzXCIpO1xuXHQgICAgICAgICAgICBcIipcIiA9PT0gd2luICYmICh3aW4gPSBudWxsKTtcblx0ICAgICAgICAgICAgXCIqXCIgPT09IGRvbWFpbiAmJiAoZG9tYWluID0gbnVsbCk7XG5cdCAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiTmFtZSByZXF1aXJlZCB0byBnZXQgcmVxdWVzdCBsaXN0ZW5lclwiKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX3JlZjMgPSBbIHdpbiwgZ2V0V2lsZGNhcmQoKSBdOyBfaTQgPCBfcmVmMy5sZW5ndGg7IF9pNCsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luUXVhbGlmaWVyID0gX3JlZjNbX2k0XTtcblx0ICAgICAgICAgICAgICAgIGlmICh3aW5RdWFsaWZpZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZUxpc3RlbmVycyA9IHJlcXVlc3RMaXN0ZW5lcnMuZ2V0KHdpblF1YWxpZmllcik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWVMaXN0ZW5lcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvbWFpbkxpc3RlbmVycyA9IG5hbWVMaXN0ZW5lcnNbbmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnMpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW4gJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgZG9tYWluKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVyc1tkb21haW5dKSByZXR1cm4gZG9tYWluTGlzdGVuZXJzW2RvbWFpbl07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbWFpbkxpc3RlbmVycy5fX2RvbWFpbl9yZWdleF9fKSBmb3IgKHZhciBfaTYgPSAwLCBfZG9tYWluTGlzdGVuZXJzJF9fRE8yID0gZG9tYWluTGlzdGVuZXJzLl9fZG9tYWluX3JlZ2V4X187IF9pNiA8IF9kb21haW5MaXN0ZW5lcnMkX19ETzIubGVuZ3RoOyBfaTYrKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2RvbWFpbkxpc3RlbmVycyRfX0RPMyA9IF9kb21haW5MaXN0ZW5lcnMkX19ETzJbX2k2XSwgbGlzdGVuZXIgPSBfZG9tYWluTGlzdGVuZXJzJF9fRE8zLmxpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hEb21haW4oX2RvbWFpbkxpc3RlbmVycyRfX0RPMy5yZWdleCwgZG9tYWluKSkgcmV0dXJuIGxpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb21haW5MaXN0ZW5lcnNbXCIqXCJdKSByZXR1cm4gZG9tYWluTGlzdGVuZXJzW1wiKlwiXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXF1ZXN0KHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCBfcmVmKSB7XG5cdCAgICAgICAgICAgIHZhciBvbiA9IF9yZWYub24sIHNlbmQgPSBfcmVmLnNlbmQ7XG5cdCAgICAgICAgICAgIHZhciBvcHRpb25zID0gZ2V0UmVxdWVzdExpc3RlbmVyKHtcblx0ICAgICAgICAgICAgICAgIG5hbWU6IG1lc3NhZ2UubmFtZSxcblx0ICAgICAgICAgICAgICAgIHdpbjogc291cmNlLFxuXHQgICAgICAgICAgICAgICAgZG9tYWluOiBvcmlnaW5cblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgIHZhciBsb2dOYW1lID0gXCJwb3N0cm9ib3RfbWV0aG9kXCIgPT09IG1lc3NhZ2UubmFtZSAmJiBtZXNzYWdlLmRhdGEgJiYgXCJzdHJpbmdcIiA9PSB0eXBlb2YgbWVzc2FnZS5kYXRhLm5hbWUgPyBtZXNzYWdlLmRhdGEubmFtZSArIFwiKClcIiA6IG1lc3NhZ2UubmFtZTtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gc2VuZFJlc3BvbnNlKGFjaywgZGF0YSwgZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5mbHVzaCgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbWVzc2FnZS5maXJlQW5kRm9yZ2V0ICYmICFpc1dpbmRvd0Nsb3NlZChzb3VyY2UpKSB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZF9zZW5kTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHVuaXF1ZUlEKCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IGdldERvbWFpbih3aW5kb3cpLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJwb3N0cm9ib3RfbWVzc2FnZV9yZXNwb25zZVwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaDogbWVzc2FnZS5oYXNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNrOiBhY2ssXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgcmVzcG9uc2UgbWVzc2FnZSBmYWlsZWQgZm9yIFwiICsgbG9nTmFtZSArIFwiIGluIFwiICsgZ2V0RG9tYWluKCkgKyBcIlxcblxcblwiICsgc3RyaW5naWZ5RXJyb3IoZXJyKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS5hbGwoWyBwcm9taXNlX1phbGdvUHJvbWlzZS5mbHVzaCgpLnRoZW4oKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLmZpcmVBbmRGb3JnZXQgJiYgIWlzV2luZG93Q2xvc2VkKHNvdXJjZSkpIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRfc2VuZE1lc3NhZ2Uoc291cmNlLCBvcmlnaW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHVuaXF1ZUlEKCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKHdpbmRvdyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicG9zdHJvYm90X21lc3NhZ2VfYWNrXCIsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IG1lc3NhZ2UuaGFzaCxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbWVzc2FnZS5uYW1lXG5cdCAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNlbmQgYWNrIG1lc3NhZ2UgZmFpbGVkIGZvciBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCJcXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KSksIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIk5vIGhhbmRsZXIgZm91bmQgZm9yIHBvc3QgbWVzc2FnZTogXCIgKyBtZXNzYWdlLm5hbWUgKyBcIiBmcm9tIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5oYW5kbGVyKHtcblx0ICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlLmRhdGFcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oZGF0YSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRSZXNwb25zZShcInN1Y2Nlc3NcIiwgZGF0YSk7XG5cdCAgICAgICAgICAgIH0pLCAoZnVuY3Rpb24oZXJyb3IpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzZW5kUmVzcG9uc2UoXCJlcnJvclwiLCBudWxsLCBlcnJvcik7XG5cdCAgICAgICAgICAgIH0pKSBdKS50aGVuKHNyY191dGlsX25vb3ApLmNhdGNoKChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuaGFuZGxlRXJyb3IpIHJldHVybiBvcHRpb25zLmhhbmRsZUVycm9yKGVycik7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gaGFuZGxlQWNrKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKSB7XG5cdCAgICAgICAgICAgIGlmICghaXNSZXNwb25zZUxpc3RlbmVyRXJyb3JlZChtZXNzYWdlLmhhc2gpKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGdldFJlc3BvbnNlTGlzdGVuZXIobWVzc2FnZS5oYXNoKTtcblx0ICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucykgdGhyb3cgbmV3IEVycm9yKFwiTm8gaGFuZGxlciBmb3VuZCBmb3IgcG9zdCBtZXNzYWdlIGFjayBmb3IgbWVzc2FnZTogXCIgKyBtZXNzYWdlLm5hbWUgKyBcIiBmcm9tIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG5cdCAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4ob3B0aW9ucy5kb21haW4sIG9yaWdpbikpIHRocm93IG5ldyBFcnJvcihcIkFjayBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBkb21haW4gXCIgKyBvcHRpb25zLmRvbWFpbi50b1N0cmluZygpKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlICE9PSBvcHRpb25zLndpbikgdGhyb3cgbmV3IEVycm9yKFwiQWNrIHNvdXJjZSBkb2VzIG5vdCBtYXRjaCByZWdpc3RlcmVkIHdpbmRvd1wiKTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMucHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIG9wdGlvbnMuYWNrID0gdHJ1ZTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXNwb25zZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSkge1xuXHQgICAgICAgICAgICBpZiAoIWlzUmVzcG9uc2VMaXN0ZW5lckVycm9yZWQobWVzc2FnZS5oYXNoKSkge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBnZXRSZXNwb25zZUxpc3RlbmVyKG1lc3NhZ2UuaGFzaCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW9wdGlvbnMpIHRocm93IG5ldyBFcnJvcihcIk5vIGhhbmRsZXIgZm91bmQgZm9yIHBvc3QgbWVzc2FnZSByZXNwb25zZSBmb3IgbWVzc2FnZTogXCIgKyBtZXNzYWdlLm5hbWUgKyBcIiBmcm9tIFwiICsgb3JpZ2luICsgXCIgaW4gXCIgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdCArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSk7XG5cdCAgICAgICAgICAgICAgICBpZiAoIW1hdGNoRG9tYWluKG9wdGlvbnMuZG9tYWluLCBvcmlnaW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBvcmlnaW4gXCIgKyBvcmlnaW4gKyBcIiBkb2VzIG5vdCBtYXRjaCBkb21haW4gXCIgKyAocGF0dGVybiA9IG9wdGlvbnMuZG9tYWluLCBcblx0ICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocGF0dGVybikgPyBcIihcIiArIHBhdHRlcm4uam9pbihcIiB8IFwiKSArIFwiKVwiIDogaXNSZWdleChwYXR0ZXJuKSA/IFwiUmVnRXhwKFwiICsgcGF0dGVybi50b1N0cmluZygpICsgXCIpXCIgOiBwYXR0ZXJuLnRvU3RyaW5nKCkpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXR0ZXJuO1xuXHQgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSAhPT0gb3B0aW9ucy53aW4pIHRocm93IG5ldyBFcnJvcihcIlJlc3BvbnNlIHNvdXJjZSBkb2VzIG5vdCBtYXRjaCByZWdpc3RlcmVkIHdpbmRvd1wiKTtcblx0ICAgICAgICAgICAgICAgIGRlbGV0ZVJlc3BvbnNlTGlzdGVuZXIobWVzc2FnZS5oYXNoKTtcblx0ICAgICAgICAgICAgICAgIFwiZXJyb3JcIiA9PT0gbWVzc2FnZS5hY2sgPyBvcHRpb25zLnByb21pc2UucmVqZWN0KG1lc3NhZ2UuZXJyb3IpIDogXCJzdWNjZXNzXCIgPT09IG1lc3NhZ2UuYWNrICYmIG9wdGlvbnMucHJvbWlzZS5yZXNvbHZlKHtcblx0ICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcblx0ICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcblx0ICAgICAgICAgICAgICAgICAgICBkYXRhOiBtZXNzYWdlLmRhdGFcblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHJlY2VpdmVfcmVjZWl2ZU1lc3NhZ2UoZXZlbnQsIF9yZWYyKSB7XG5cdCAgICAgICAgICAgIHZhciBvbiA9IF9yZWYyLm9uLCBzZW5kID0gX3JlZjIuc2VuZDtcblx0ICAgICAgICAgICAgdmFyIHJlY2VpdmVkTWVzc2FnZXMgPSBnbG9iYWxTdG9yZShcInJlY2VpdmVkTWVzc2FnZXNcIik7XG5cdCAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIXdpbmRvdyB8fCB3aW5kb3cuY2xvc2VkIHx8ICFldmVudC5zb3VyY2UpIHJldHVybjtcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2ZW50LnNvdXJjZSwgb3JpZ2luID0gZXZlbnQub3JpZ2luO1xuXHQgICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBmdW5jdGlvbihtZXNzYWdlLCBzb3VyY2UsIG9yaWdpbiwgX3JlZikge1xuXHQgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZi5vbiwgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgICAgIHZhciBwYXJzZWRNZXNzYWdlO1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICBwYXJzZWRNZXNzYWdlID0gZGVzZXJpYWxpemVNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKHBhcnNlZE1lc3NhZ2UgJiYgXCJvYmplY3RcIiA9PSB0eXBlb2YgcGFyc2VkTWVzc2FnZSAmJiBudWxsICE9PSBwYXJzZWRNZXNzYWdlKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnNlTWVzc2FnZXMgPSBwYXJzZWRNZXNzYWdlLl9fcG9zdF9yb2JvdF8xMF8wXzQ2X187XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyc2VNZXNzYWdlcykpIHJldHVybiBwYXJzZU1lc3NhZ2VzO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KGV2ZW50LmRhdGEsIHNvdXJjZSwgb3JpZ2luLCB7XG5cdCAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICBpZiAobWVzc2FnZXMpIHtcblx0ICAgICAgICAgICAgICAgIG1hcmtXaW5kb3dLbm93bihzb3VyY2UpO1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbWVzc2FnZXMubGVuZ3RoOyBfaTIrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZXNbX2kyXTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRNZXNzYWdlcy5oYXMobWVzc2FnZS5pZCkpIHJldHVybjtcblx0ICAgICAgICAgICAgICAgICAgICByZWNlaXZlZE1lc3NhZ2VzLnNldChtZXNzYWdlLmlkLCB0cnVlKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQoc291cmNlKSAmJiAhbWVzc2FnZS5maXJlQW5kRm9yZ2V0KSByZXR1cm47XG5cdCAgICAgICAgICAgICAgICAgICAgMCA9PT0gbWVzc2FnZS5vcmlnaW4uaW5kZXhPZihcImZpbGU6XCIpICYmIChvcmlnaW4gPSBcImZpbGU6Ly9cIik7XG5cdCAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgXCJwb3N0cm9ib3RfbWVzc2FnZV9yZXF1ZXN0XCIgPT09IG1lc3NhZ2UudHlwZSA/IGhhbmRsZVJlcXVlc3Qoc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkgOiBcInBvc3Ryb2JvdF9tZXNzYWdlX3Jlc3BvbnNlXCIgPT09IG1lc3NhZ2UudHlwZSA/IGhhbmRsZVJlc3BvbnNlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlKSA6IFwicG9zdHJvYm90X21lc3NhZ2VfYWNrXCIgPT09IG1lc3NhZ2UudHlwZSAmJiBoYW5kbGVBY2soc291cmNlLCBvcmlnaW4sIG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSksIDApO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBvbl9vbihuYW1lLCBvcHRpb25zLCBoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgbmFtZVwiKTtcblx0ICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgKG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9KSkge1xuXHQgICAgICAgICAgICAgICAgaGFuZGxlciA9IG9wdGlvbnM7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBoYW5kbGVyXCIpO1xuXHQgICAgICAgICAgICB2YXIgcmVxdWVzdExpc3RlbmVyID0gZnVuY3Rpb24gYWRkUmVxdWVzdExpc3RlbmVyKF9yZWY0LCBsaXN0ZW5lcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmNC5uYW1lLCB3aW5DYW5kaWRhdGUgPSBfcmVmNC53aW4sIGRvbWFpbiA9IF9yZWY0LmRvbWFpbjtcblx0ICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0TGlzdGVuZXJzID0gd2luZG93U3RvcmUoXCJyZXF1ZXN0TGlzdGVuZXJzXCIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKCFuYW1lIHx8IFwic3RyaW5nXCIgIT0gdHlwZW9mIG5hbWUpIHRocm93IG5ldyBFcnJvcihcIk5hbWUgcmVxdWlyZWQgdG8gYWRkIHJlcXVlc3QgbGlzdGVuZXJcIik7XG5cdCAgICAgICAgICAgICAgICBpZiAod2luQ2FuZGlkYXRlICYmIFwiKlwiICE9PSB3aW5DYW5kaWRhdGUgJiYgd2luZG93X1Byb3h5V2luZG93LmlzUHJveHlXaW5kb3cod2luQ2FuZGlkYXRlKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0TGlzdGVuZXJQcm9taXNlID0gd2luQ2FuZGlkYXRlLmF3YWl0V2luZG93KCkudGhlbigoZnVuY3Rpb24oYWN0dWFsV2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhZGRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogYWN0dWFsV2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXIpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdExpc3RlbmVyUHJvbWlzZS50aGVuKChmdW5jdGlvbihyZXF1ZXN0TGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdExpc3RlbmVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksIHNyY191dGlsX25vb3ApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIHZhciB3aW4gPSB3aW5DYW5kaWRhdGU7XG5cdCAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh3aW4pKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3RlbmVyc0NvbGxlY3Rpb24gPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTggPSAwLCBfd2luMiA9IHdpbjsgX2k4IDwgX3dpbjIubGVuZ3RoOyBfaTgrKykgbGlzdGVuZXJzQ29sbGVjdGlvbi5wdXNoKGFkZFJlcXVlc3RMaXN0ZW5lcih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogZG9tYWluLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB3aW46IF93aW4yW19pOF1cblx0ICAgICAgICAgICAgICAgICAgICB9LCBsaXN0ZW5lcikpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTEwID0gMDsgX2kxMCA8IGxpc3RlbmVyc0NvbGxlY3Rpb24ubGVuZ3RoOyBfaTEwKyspIGxpc3RlbmVyc0NvbGxlY3Rpb25bX2kxMF0uY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZG9tYWluKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBfbGlzdGVuZXJzQ29sbGVjdGlvbiA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pMTIgPSAwLCBfZG9tYWluMiA9IGRvbWFpbjsgX2kxMiA8IF9kb21haW4yLmxlbmd0aDsgX2kxMisrKSBfbGlzdGVuZXJzQ29sbGVjdGlvbi5wdXNoKGFkZFJlcXVlc3RMaXN0ZW5lcih7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbjogd2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IF9kb21haW4yW19pMTJdXG5cdCAgICAgICAgICAgICAgICAgICAgfSwgbGlzdGVuZXIpKTtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kxNCA9IDA7IF9pMTQgPCBfbGlzdGVuZXJzQ29sbGVjdGlvbi5sZW5ndGg7IF9pMTQrKykgX2xpc3RlbmVyc0NvbGxlY3Rpb25bX2kxNF0uY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nTGlzdGVuZXIgPSBnZXRSZXF1ZXN0TGlzdGVuZXIoe1xuXHQgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG5cdCAgICAgICAgICAgICAgICAgICAgd2luOiB3aW4sXG5cdCAgICAgICAgICAgICAgICAgICAgZG9tYWluOiBkb21haW5cblx0ICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgd2luICYmIFwiKlwiICE9PSB3aW4gfHwgKHdpbiA9IGdldFdpbGRjYXJkKCkpO1xuXHQgICAgICAgICAgICAgICAgdmFyIHN0ckRvbWFpbiA9IChkb21haW4gPSBkb21haW4gfHwgXCIqXCIpLnRvU3RyaW5nKCk7XG5cdCAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdMaXN0ZW5lcikgdGhyb3cgd2luICYmIGRvbWFpbiA/IG5ldyBFcnJvcihcIlJlcXVlc3QgbGlzdGVuZXIgYWxyZWFkeSBleGlzdHMgZm9yIFwiICsgbmFtZSArIFwiIG9uIGRvbWFpbiBcIiArIGRvbWFpbi50b1N0cmluZygpICsgXCIgZm9yIFwiICsgKHdpbiA9PT0gZ2V0V2lsZGNhcmQoKSA/IFwid2lsZGNhcmRcIiA6IFwic3BlY2lmaWVkXCIpICsgXCIgd2luZG93XCIpIDogd2luID8gbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lICsgXCIgZm9yIFwiICsgKHdpbiA9PT0gZ2V0V2lsZGNhcmQoKSA/IFwid2lsZGNhcmRcIiA6IFwic3BlY2lmaWVkXCIpICsgXCIgd2luZG93XCIpIDogZG9tYWluID8gbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lICsgXCIgb24gZG9tYWluIFwiICsgZG9tYWluLnRvU3RyaW5nKCkpIDogbmV3IEVycm9yKFwiUmVxdWVzdCBsaXN0ZW5lciBhbHJlYWR5IGV4aXN0cyBmb3IgXCIgKyBuYW1lKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lTGlzdGVuZXJzID0gcmVxdWVzdExpc3RlbmVycy5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG5cdCAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZURvbWFpbkxpc3RlbmVycyA9IHV0aWxfZ2V0T3JTZXQod2luTmFtZUxpc3RlbmVycywgbmFtZSwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiB7fTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIHZhciB3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnM7XG5cdCAgICAgICAgICAgICAgICB2YXIgd2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXI7XG5cdCAgICAgICAgICAgICAgICB1dGlsX2lzUmVnZXgoZG9tYWluKSA/ICh3aW5OYW1lRG9tYWluUmVnZXhMaXN0ZW5lcnMgPSB1dGlsX2dldE9yU2V0KHdpbk5hbWVEb21haW5MaXN0ZW5lcnMsIFwiX19kb21haW5fcmVnZXhfX1wiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgICAgICAgICAgfSkpKS5wdXNoKHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVyID0ge1xuXHQgICAgICAgICAgICAgICAgICAgIHJlZ2V4OiBkb21haW4sXG5cdCAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG5cdCAgICAgICAgICAgICAgICB9KSA6IHdpbk5hbWVEb21haW5MaXN0ZW5lcnNbc3RyRG9tYWluXSA9IGxpc3RlbmVyO1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgd2luTmFtZURvbWFpbkxpc3RlbmVyc1tzdHJEb21haW5dO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVycy5zcGxpY2Uod2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXJzLmluZGV4T2Yod2luTmFtZURvbWFpblJlZ2V4TGlzdGVuZXIsIDEpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbk5hbWVEb21haW5SZWdleExpc3RlbmVycy5sZW5ndGggfHwgZGVsZXRlIHdpbk5hbWVEb21haW5MaXN0ZW5lcnMuX19kb21haW5fcmVnZXhfXztcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh3aW5OYW1lRG9tYWluTGlzdGVuZXJzKS5sZW5ndGggfHwgZGVsZXRlIHdpbk5hbWVMaXN0ZW5lcnNbbmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHdpbiAmJiAhT2JqZWN0LmtleXMod2luTmFtZUxpc3RlbmVycykubGVuZ3RoICYmIHJlcXVlc3RMaXN0ZW5lcnMuZGVsKHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfSh7XG5cdCAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgd2luOiBvcHRpb25zLndpbmRvdyxcblx0ICAgICAgICAgICAgICAgIGRvbWFpbjogb3B0aW9ucy5kb21haW4gfHwgXCIqXCJcblx0ICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlciB8fCBvcHRpb25zLmhhbmRsZXIsXG5cdCAgICAgICAgICAgICAgICBoYW5kbGVFcnJvcjogb3B0aW9ucy5lcnJvckhhbmRsZXIgfHwgZnVuY3Rpb24oZXJyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmVxdWVzdExpc3RlbmVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBvbl9vbmNlKG5hbWUsIG9wdGlvbnMsIGhhbmRsZXIpIHtcblx0ICAgICAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgKG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9KSkge1xuXHQgICAgICAgICAgICAgICAgaGFuZGxlciA9IG9wdGlvbnM7XG5cdCAgICAgICAgICAgICAgICBvcHRpb25zID0ge307XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgcHJvbWlzZV9aYWxnb1Byb21pc2U7XG5cdCAgICAgICAgICAgIHZhciBsaXN0ZW5lcjtcblx0ICAgICAgICAgICAgb3B0aW9ucy5lcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgbGlzdGVuZXIgPSBvbl9vbihuYW1lLCBvcHRpb25zLCAoZnVuY3Rpb24oZXZlbnQpIHtcblx0ICAgICAgICAgICAgICAgIGxpc3RlbmVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKGV2ZW50KTtcblx0ICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSByZXR1cm4gaGFuZGxlcihldmVudCk7XG5cdCAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgcHJvbWlzZS5jYW5jZWwgPSBsaXN0ZW5lci5jYW5jZWw7XG5cdCAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuXHQgICAgICAgIH1cblx0ICAgICAgICB2YXIgc2VuZF9zZW5kID0gZnVuY3Rpb24gc2VuZCh3aW5PclByb3h5V2luLCBuYW1lLCBkYXRhLCBvcHRpb25zKSB7XG5cdCAgICAgICAgICAgIHZhciBkb21haW5NYXRjaGVyID0gKG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9KS5kb21haW4gfHwgXCIqXCI7XG5cdCAgICAgICAgICAgIHZhciByZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgLTE7XG5cdCAgICAgICAgICAgIHZhciBjaGlsZFRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQgfHwgNWUzO1xuXHQgICAgICAgICAgICB2YXIgZmlyZUFuZEZvcmdldCA9IG9wdGlvbnMuZmlyZUFuZEZvcmdldCB8fCBmYWxzZTtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHdpbk9yUHJveHlXaW4sIHtcblx0ICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgfSkuYXdhaXRXaW5kb3coKS50aGVuKChmdW5jdGlvbih3aW4pIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBwcm9taXNlX1phbGdvUHJvbWlzZS50cnkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbihuYW1lLCB3aW4sIGRvbWFpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIG5hbWVcIik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiBkb21haW4gJiYgIUFycmF5LmlzQXJyYXkoZG9tYWluKSAmJiAhdXRpbF9pc1JlZ2V4KGRvbWFpbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW4gbm90IHNlbmQgXCIgKyBuYW1lICsgXCIuIEV4cGVjdGVkIGRvbWFpbiBcIiArIEpTT04uc3RyaW5naWZ5KGRvbWFpbikgKyBcIiB0byBiZSBhIHN0cmluZywgYXJyYXksIG9yIHJlZ2V4XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNXaW5kb3dDbG9zZWQod2luKSkgdGhyb3cgbmV3IEVycm9yKFwiQ2FuIG5vdCBzZW5kIFwiICsgbmFtZSArIFwiLiBUYXJnZXQgd2luZG93IGlzIGNsb3NlZFwiKTtcblx0ICAgICAgICAgICAgICAgICAgICB9KG5hbWUsIHdpbiwgZG9tYWluTWF0Y2hlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKGZ1bmN0aW9uKHBhcmVudCwgY2hpbGQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFjdHVhbFBhcmVudCA9IGdldEFuY2VzdG9yKGNoaWxkKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjdHVhbFBhcmVudCkgcmV0dXJuIGFjdHVhbFBhcmVudCA9PT0gcGFyZW50O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQgPT09IHBhcmVudCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2b2lkIDAgPT09IHdpbiAmJiAod2luID0gd2luZG93KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdpbi50b3ApIHJldHVybiB3aW4udG9wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldFBhcmVudCh3aW4pID09PSB3aW4pIHJldHVybiB3aW47XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FuY2VzdG9yUGFyZW50KHdpbmRvdywgd2luKSAmJiB3aW5kb3cudG9wKSByZXR1cm4gd2luZG93LnRvcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQW5jZXN0b3JQYXJlbnQod2luLCB3aW5kb3cpICYmIHdpbmRvdy50b3ApIHJldHVybiB3aW5kb3cudG9wO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k3ID0gMCwgX2dldEFsbENoaWxkRnJhbWVzNCA9IGZ1bmN0aW9uIGdldEFsbENoaWxkRnJhbWVzKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwLCBfZ2V0RnJhbWVzMiA9IGdldEZyYW1lcyh3aW4pOyBfaTMgPCBfZ2V0RnJhbWVzMi5sZW5ndGg7IF9pMysrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFtZSA9IF9nZXRGcmFtZXMyW19pM107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZyYW1lKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2k1ID0gMCwgX2dldEFsbENoaWxkRnJhbWVzMiA9IGdldEFsbENoaWxkRnJhbWVzKGZyYW1lKTsgX2k1IDwgX2dldEFsbENoaWxkRnJhbWVzMi5sZW5ndGg7IF9pNSsrKSByZXN1bHQucHVzaChfZ2V0QWxsQ2hpbGRGcmFtZXMyW19pNV0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSh3aW4pOyBfaTcgPCBfZ2V0QWxsQ2hpbGRGcmFtZXM0Lmxlbmd0aDsgX2k3KyspIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhbWUgPSBfZ2V0QWxsQ2hpbGRGcmFtZXM0W19pN107XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYW1lLnRvcCkgcmV0dXJuIGZyYW1lLnRvcDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdldFBhcmVudChmcmFtZSkgPT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0oY2hpbGQpID09PSBjaGlsZCkgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTE1ID0gMCwgX2dldEZyYW1lczggPSBnZXRGcmFtZXMocGFyZW50KTsgX2kxNSA8IF9nZXRGcmFtZXM4Lmxlbmd0aDsgX2kxNSsrKSBpZiAoX2dldEZyYW1lczhbX2kxNV0gPT09IGNoaWxkKSByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICAgICAgICAgICAgICAgIH0od2luZG93LCB3aW4pKSByZXR1cm4gZnVuY3Rpb24od2luLCB0aW1lb3V0LCBuYW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gdGltZW91dCAmJiAodGltZW91dCA9IDVlMyk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZvaWQgMCA9PT0gbmFtZSAmJiAobmFtZSA9IFwiV2luZG93XCIpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcHJvbWlzZSA9IGZ1bmN0aW9uKHdpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvd1N0b3JlKFwiaGVsbG9Qcm9taXNlc1wiKS5nZXRPclNldCh3aW4sIChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC0xICE9PSB0aW1lb3V0ICYmIChwcm9taXNlID0gcHJvbWlzZS50aW1lb3V0KHRpbWVvdXQsIG5ldyBFcnJvcihuYW1lICsgXCIgZGlkIG5vdCBsb2FkIGFmdGVyIFwiICsgdGltZW91dCArIFwibXNcIikpKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh3aW4sIGNoaWxkVGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24oX3RlbXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24od2luLCB0YXJnZXREb21haW4sIGFjdHVhbERvbWFpbiwgX3JlZikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VuZCA9IF9yZWYuc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgdGFyZ2V0RG9tYWluID8gdGFyZ2V0RG9tYWluIDogcHJvbWlzZV9aYWxnb1Byb21pc2UudHJ5KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0dWFsRG9tYWluIHx8IHNheUhlbGxvKHdpbiwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkudGhlbigoZnVuY3Rpb24oX3JlZjIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmRvbWFpbjtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSkudGhlbigoZnVuY3Rpb24obm9ybWFsaXplZERvbWFpbikge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbWF0Y2hEb21haW4odGFyZ2V0RG9tYWluLCB0YXJnZXREb21haW4pKSB0aHJvdyBuZXcgRXJyb3IoXCJEb21haW4gXCIgKyBzdHJpbmdpZnkodGFyZ2V0RG9tYWluKSArIFwiIGRvZXMgbm90IG1hdGNoIFwiICsgc3RyaW5naWZ5KHRhcmdldERvbWFpbikpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRG9tYWluO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSh3aW4sIGRvbWFpbk1hdGNoZXIsICh2b2lkIDAgPT09IF90ZW1wID8ge30gOiBfdGVtcCkuZG9tYWluLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgIH0pKS50aGVuKChmdW5jdGlvbih0YXJnZXREb21haW4pIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZG9tYWluID0gdGFyZ2V0RG9tYWluO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBsb2dOYW1lID0gXCJwb3N0cm9ib3RfbWV0aG9kXCIgPT09IG5hbWUgJiYgZGF0YSAmJiBcInN0cmluZ1wiID09IHR5cGVvZiBkYXRhLm5hbWUgPyBkYXRhLm5hbWUgKyBcIigpXCIgOiBuYW1lO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IHByb21pc2VfWmFsZ29Qcm9taXNlO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gbmFtZSArIFwiX1wiICsgdW5pcXVlSUQoKTtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIWZpcmVBbmRGb3JnZXQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlTGlzdGVuZXIgPSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luOiB3aW4sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb21haW46IGRvbWFpbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2U6IHByb21pc2Vcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGhhc2gsIGxpc3RlbmVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcInJlc3BvbnNlTGlzdGVuZXJzXCIpLnNldChoYXNoLCBsaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0oaGFzaCwgcmVzcG9uc2VMaXN0ZW5lcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXFQcm9taXNlcyA9IHdpbmRvd1N0b3JlKFwicmVxdWVzdFByb21pc2VzXCIpLmdldE9yU2V0KHdpbiwgKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJlcVByb21pc2VzLnB1c2gocHJvbWlzZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2UuY2F0Y2goKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKGhhc2gpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZShcImVycm9yZWRSZXNwb25zZUxpc3RlbmVyc1wiKS5zZXQoaGFzaCwgdHJ1ZSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGhhc2gpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlUmVzcG9uc2VMaXN0ZW5lcihoYXNoKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG90YWxBY2tUaW1lb3V0ID0gZnVuY3Rpb24od2luKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93U3RvcmUoXCJrbm93bldpbmRvd3NcIikuZ2V0KHdpbiwgZmFsc2UpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbikgPyAxZTQgOiAyZTM7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3RhbFJlc1RpbWVvdXQgPSByZXNwb25zZVRpbWVvdXQ7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhY2tUaW1lb3V0ID0gdG90YWxBY2tUaW1lb3V0O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzVGltZW91dCA9IHRvdGFsUmVzVGltZW91dDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gZnVuY3Rpb24obWV0aG9kLCB0aW1lKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGltZW91dDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICFmdW5jdGlvbiBsb29wKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIWZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzV2luZG93Q2xvc2VkKHdpbikpIHJldHVybiBwcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJXaW5kb3cgY2xvc2VkIGZvciBcIiArIG5hbWUgKyBcIiBiZWZvcmUgXCIgKyAocmVzcG9uc2VMaXN0ZW5lci5hY2sgPyBcInJlc3BvbnNlXCIgOiBcImFja1wiKSkpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlTGlzdGVuZXIuY2FuY2VsbGVkKSByZXR1cm4gcHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiUmVzcG9uc2UgbGlzdGVuZXIgd2FzIGNhbmNlbGxlZCBmb3IgXCIgKyBuYW1lKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2tUaW1lb3V0ID0gTWF0aC5tYXgoYWNrVGltZW91dCAtIDUwMCwgMCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtMSAhPT0gcmVzVGltZW91dCAmJiAocmVzVGltZW91dCA9IE1hdGgubWF4KHJlc1RpbWVvdXQgLSA1MDAsIDApKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTGlzdGVuZXIuYWNrIHx8IDAgIT09IGFja1RpbWVvdXQgPyAwID09PSByZXNUaW1lb3V0ICYmIHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIHJlc3BvbnNlIGZvciBwb3N0TWVzc2FnZSBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCIgaW4gXCIgKyB0b3RhbFJlc1RpbWVvdXQgKyBcIm1zXCIpKSA6IHByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIk5vIGFjayBmb3IgcG9zdE1lc3NhZ2UgXCIgKyBsb2dOYW1lICsgXCIgaW4gXCIgKyBnZXREb21haW4oKSArIFwiIGluIFwiICsgdG90YWxBY2tUaW1lb3V0ICsgXCJtc1wiKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9vcCgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCA1MDApO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlLmZpbmFsbHkoKGZ1bmN0aW9uKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWwuY2FuY2VsKCk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXFQcm9taXNlcy5zcGxpY2UocmVxUHJvbWlzZXMuaW5kZXhPZihwcm9taXNlLCAxKSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pKS5jYXRjaChzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbmRfc2VuZE1lc3NhZ2Uod2luLCBkb21haW4sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHVuaXF1ZUlEKCksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogZ2V0RG9tYWluKHdpbmRvdyksXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwicG9zdHJvYm90X21lc3NhZ2VfcmVxdWVzdFwiLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBoYXNoOiBoYXNoLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICBmaXJlQW5kRm9yZ2V0OiBmaXJlQW5kRm9yZ2V0XG5cdCAgICAgICAgICAgICAgICAgICAgfSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICB9KS50aGVuKChmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpcmVBbmRGb3JnZXQgPyBwcm9taXNlLnJlc29sdmUoKSA6IHByb21pc2U7XG5cdCAgICAgICAgICAgICAgICAgICAgfSksIChmdW5jdGlvbihlcnIpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VuZCByZXF1ZXN0IG1lc3NhZ2UgZmFpbGVkIGZvciBcIiArIGxvZ05hbWUgKyBcIiBpbiBcIiArIGdldERvbWFpbigpICsgXCJcXG5cXG5cIiArIHN0cmluZ2lmeUVycm9yKGVycikpO1xuXHQgICAgICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgICAgIH0pKTtcblx0ICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgIH07XG5cdCAgICAgICAgZnVuY3Rpb24gc2V0dXBfc2VyaWFsaXplTWVzc2FnZShkZXN0aW5hdGlvbiwgZG9tYWluLCBvYmopIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZU1lc3NhZ2UoZGVzdGluYXRpb24sIGRvbWFpbiwgb2JqLCB7XG5cdCAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIHNldHVwX2Rlc2VyaWFsaXplTWVzc2FnZShzb3VyY2UsIG9yaWdpbiwgbWVzc2FnZSkge1xuXHQgICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVNZXNzYWdlKHNvdXJjZSwgb3JpZ2luLCBtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVByb3h5V2luZG93KHdpbikge1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IHdpbmRvd19Qcm94eVdpbmRvdyh7XG5cdCAgICAgICAgICAgICAgICBzZW5kOiBzZW5kX3NlbmQsXG5cdCAgICAgICAgICAgICAgICB3aW46IHdpblxuXHQgICAgICAgICAgICB9KTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgZnVuY3Rpb24gc2V0dXBfdG9Qcm94eVdpbmRvdyh3aW4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHdpbmRvd19Qcm94eVdpbmRvdy50b1Byb3h5V2luZG93KHdpbiwge1xuXHQgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH1cblx0ICAgICAgICBmdW5jdGlvbiBzZXR1cCgpIHtcblx0ICAgICAgICAgICAgaWYgKCFnbG9iYWxfZ2V0R2xvYmFsKCkuaW5pdGlhbGl6ZWQpIHtcblx0ICAgICAgICAgICAgICAgIGdsb2JhbF9nZXRHbG9iYWwoKS5pbml0aWFsaXplZCA9IHRydWU7XG5cdCAgICAgICAgICAgICAgICBvbiA9IChfcmVmMyA9IHtcblx0ICAgICAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgICAgICB9KS5vbiwgc2VuZCA9IF9yZWYzLnNlbmQsIChnbG9iYWwgPSBnbG9iYWxfZ2V0R2xvYmFsKCkpLnJlY2VpdmVNZXNzYWdlID0gZ2xvYmFsLnJlY2VpdmVNZXNzYWdlIHx8IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVjZWl2ZV9yZWNlaXZlTWVzc2FnZShtZXNzYWdlLCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIG9uOiBvbixcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgICFmdW5jdGlvbihfcmVmNSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBvbiA9IF9yZWY1Lm9uLCBzZW5kID0gX3JlZjUuc2VuZDtcblx0ICAgICAgICAgICAgICAgICAgICBnbG9iYWxTdG9yZSgpLmdldE9yU2V0KFwicG9zdE1lc3NhZ2VMaXN0ZW5lclwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihvYmosIGV2ZW50LCBoYW5kbGVyKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlcik7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBoYW5kbGVyKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KHdpbmRvdywgMCwgKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAhZnVuY3Rpb24oZXZlbnQsIF9yZWY0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9uID0gX3JlZjQub24sIHNlbmQgPSBfcmVmNC5zZW5kO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb21pc2VfWmFsZ29Qcm9taXNlLnRyeSgoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldmVudC5zb3VyY2UgfHwgZXZlbnQuc291cmNlRWxlbWVudDtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9yaWdpbiA9IGV2ZW50Lm9yaWdpbiB8fCBldmVudC5vcmlnaW5hbEV2ZW50ICYmIGV2ZW50Lm9yaWdpbmFsRXZlbnQub3JpZ2luO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGV2ZW50LmRhdGE7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwibnVsbFwiID09PSBvcmlnaW4gJiYgKG9yaWdpbiA9IFwiZmlsZTovL1wiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcmlnaW4pIHRocm93IG5ldyBFcnJvcihcIlBvc3QgbWVzc2FnZSBkaWQgbm90IGhhdmUgb3JpZ2luIGRvbWFpblwiKTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVfcmVjZWl2ZU1lc3NhZ2Uoe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjogb24sXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KGV2ZW50LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IG9uLFxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSkpO1xuXHQgICAgICAgICAgICAgICAgfSh7XG5cdCAgICAgICAgICAgICAgICAgICAgb246IG9uX29uLFxuXHQgICAgICAgICAgICAgICAgICAgIHNlbmQ6IHNlbmRfc2VuZFxuXHQgICAgICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgICAgICAgICAhZnVuY3Rpb24oX3JlZjgpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgb24gPSBfcmVmOC5vbiwgc2VuZCA9IF9yZWY4LnNlbmQ7XG5cdCAgICAgICAgICAgICAgICAgICAgZ2xvYmFsU3RvcmUoXCJidWlsdGluTGlzdGVuZXJzXCIpLmdldE9yU2V0KFwiaGVsbG9MaXN0ZW5lclwiLCAoZnVuY3Rpb24oKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IG9uKFwicG9zdHJvYm90X2hlbGxvXCIsIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogXCIqXCJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfSwgKGZ1bmN0aW9uKF9yZWYzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlSGVsbG9Qcm9taXNlKF9yZWYzLnNvdXJjZSwge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvbWFpbjogX3JlZjMub3JpZ2luXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VJRDogZ2V0SW5zdGFuY2VJRCgpXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSBnZXRBbmNlc3RvcigpO1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQgJiYgc2F5SGVsbG8ocGFyZW50LCB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kOiBzZW5kXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIH0pLmNhdGNoKChmdW5jdGlvbihlcnIpIHt9KSk7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcblx0ICAgICAgICAgICAgICAgICAgICB9KSk7XG5cdCAgICAgICAgICAgICAgICB9KHtcblx0ICAgICAgICAgICAgICAgICAgICBvbjogb25fb24sXG5cdCAgICAgICAgICAgICAgICAgICAgc2VuZDogc2VuZF9zZW5kXG5cdCAgICAgICAgICAgICAgICB9KTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgX3JlZjMsIG9uLCBzZW5kLCBnbG9iYWw7XG5cdCAgICAgICAgfVxuXHQgICAgICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdCAgICAgICAgICAgICFmdW5jdGlvbigpIHtcblx0ICAgICAgICAgICAgICAgIHZhciByZXNwb25zZUxpc3RlbmVycyA9IGdsb2JhbFN0b3JlKFwicmVzcG9uc2VMaXN0ZW5lcnNcIik7XG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfcmVzcG9uc2VMaXN0ZW5lcnMka2UyID0gcmVzcG9uc2VMaXN0ZW5lcnMua2V5cygpOyBfaTIgPCBfcmVzcG9uc2VMaXN0ZW5lcnMka2UyLmxlbmd0aDsgX2kyKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IF9yZXNwb25zZUxpc3RlbmVycyRrZTJbX2kyXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXIgPSByZXNwb25zZUxpc3RlbmVycy5nZXQoaGFzaCk7XG5cdCAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIgJiYgKGxpc3RlbmVyLmNhbmNlbGxlZCA9IHRydWUpO1xuXHQgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTGlzdGVuZXJzLmRlbChoYXNoKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfSgpO1xuXHQgICAgICAgICAgICAobGlzdGVuZXIgPSBnbG9iYWxTdG9yZSgpLmdldChcInBvc3RNZXNzYWdlTGlzdGVuZXJcIikpICYmIGxpc3RlbmVyLmNhbmNlbCgpO1xuXHQgICAgICAgICAgICB2YXIgbGlzdGVuZXI7XG5cdCAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuX19wb3N0X3JvYm90XzEwXzBfNDZfXztcblx0ICAgICAgICB9XG5cdCAgICAgICAgdmFyIHNyY190eXBlc19UWVBFU18wID0gdHJ1ZTtcblx0ICAgICAgICBmdW5jdGlvbiBjbGVhblVwV2luZG93KHdpbikge1xuXHQgICAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfcmVxdWVzdFByb21pc2VzJGdldDIgPSB3aW5kb3dTdG9yZShcInJlcXVlc3RQcm9taXNlc1wiKS5nZXQod2luLCBbXSk7IF9pMiA8IF9yZXF1ZXN0UHJvbWlzZXMkZ2V0Mi5sZW5ndGg7IF9pMisrKSBfcmVxdWVzdFByb21pc2VzJGdldDJbX2kyXS5yZWplY3QobmV3IEVycm9yKFwiV2luZG93IFwiICsgKGlzV2luZG93Q2xvc2VkKHdpbikgPyBcImNsb3NlZFwiIDogXCJjbGVhbmVkIHVwXCIpICsgXCIgYmVmb3JlIHJlc3BvbnNlXCIpKS5jYXRjaChzcmNfdXRpbF9ub29wKTtcblx0ICAgICAgICB9XG5cdCAgICAgICAgc2V0dXAoKTtcblx0ICAgIH0gXSk7XG5cdH0pKTsgXG59IChwb3N0Um9ib3QpKTtcblxudmFyIHBvc3RSb2JvdEV4cG9ydHMkMSA9IHBvc3RSb2JvdC5leHBvcnRzO1xuXG4vKiBAZmxvdyAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkge1xuXHQvLyAkRmxvd0ZpeE1lXG5cdG1vZHVsZS5leHBvcnRzID0gcG9zdFJvYm90RXhwb3J0cyQxOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1jb21tb25qc1xuXG5cdC8vICRGbG93Rml4TWVcblx0bW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGltcG9ydC9uby1jb21tb25qcyBcbn0gKHBvc3RSb2JvdCQxKSk7XG5cbnZhciBwb3N0Um9ib3RFeHBvcnRzID0gcG9zdFJvYm90JDEuZXhwb3J0cztcbnZhciBpbmRleCA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhwb3N0Um9ib3RFeHBvcnRzKTtcblxudmFyIGluZGV4JDEgPSAvKiNfX1BVUkVfXyovX21lcmdlTmFtZXNwYWNlcyh7XG5cdF9fcHJvdG9fXzogbnVsbCxcblx0ZGVmYXVsdDogaW5kZXhcbn0sIFtwb3N0Um9ib3RFeHBvcnRzXSk7XG5cbmV4cG9ydCB7IGluZGV4JDEgYXMgaSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/family/lib/index-Cs-onntv.js\n"));

/***/ })

}]);